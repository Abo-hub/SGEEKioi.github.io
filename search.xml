<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="/2019/07/25/pringmatrix/"/>
      <url>/2019/07/25/pringmatrix/</url>
      
        <content type="html"><![CDATA[<h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>给定一个矩阵matrix，请按照顺时针的方式打印它。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span></span><br><span class="line"><span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>打印结果为：1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>本体上算法没有难度，关键在于设计一种容易理解、代码易于实现的方式。我们可以采用矩阵分圈处理。在矩阵中用左上角的坐标(lx,ly)和右下角的坐标(rx,ry)就可以表示一个子矩阵。比如题目中的矩阵，当(lx,ly)=(0,0)、(rx,ry)=(3,3)时，表示的子矩阵就是整个矩阵，那么这个子矩阵的最外层的部分如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">5</span>           <span class="number">8</span></span><br><span class="line"><span class="number">9</span>           <span class="number">12</span></span><br><span class="line"><span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>我们可以先把矩阵的最外层打印出来，接下来令lx和ly加1，rx和ry减1，即(lx,ly)=(1,1)、(rx,ry)=(2,2),此时表示的子矩阵如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">10</span>  <span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>再把这个子矩阵转圈打印出来即可。如果发现左上角坐标跑到了右下角的右方或下方，整个过程结束。我们将每次打印的结果放到一个list数组里最后输出即可。(当然，你也可以选择每次循环时直接打印值)<br>具体过程参看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintMatrix</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rx = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ry = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ly &lt;= rx &amp;&amp; ly &lt;= ry) &#123;</span><br><span class="line">            printEdge(matrix, ly++, ly++, rx--, ry--);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子矩阵只有一行时</span></span><br><span class="line">        <span class="keyword">if</span> (lx == rx) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ly; i &lt;= ry; i++) &#123;</span><br><span class="line">                list.add(matrix[lx][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//子矩阵只有一列时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ly == ry) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; i++) &#123;</span><br><span class="line">                list.add(matrix[i][ly]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curC = ly;</span><br><span class="line">            <span class="keyword">int</span> curR = lx;</span><br><span class="line">            <span class="keyword">while</span> (curC != ry) &#123;</span><br><span class="line">                list.add(matrix[lx][curC]);</span><br><span class="line">                curC++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != rx) &#123;</span><br><span class="line">                list.add(matrix[curR][ry]);</span><br><span class="line">                curR++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC != ly) &#123;</span><br><span class="line">                list.add(matrix[rx][curC]);</span><br><span class="line">                curC--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != lx) &#123;</span><br><span class="line">                list.add(matrix[curR][ly]);</span><br><span class="line">                curR--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O 总结</title>
      <link href="/2019/07/25/javaio/"/>
      <url>/2019/07/25/javaio/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I/O流"></a>Java I/O流</h1><p><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/JavaIO.png?raw=true"></p><h2 id="一、-Java-IO-原理"><a href="#一、-Java-IO-原理" class="headerlink" title="一、 Java IO 原理"></a>一、 Java IO 原理</h2><ul><li>输入 input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。</li><li>输出 output：将程序(内存)数据输出到磁盘、光盘等存储设备中。</li></ul><h2 id="二、-流的分类"><a href="#二、-流的分类" class="headerlink" title="二、 流的分类"></a>二、 流的分类</h2><ul><li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li><li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li><li>按流的<strong>角色</strong>的不同分为：节点流，处理流</li></ul><div class="table-container"><table><thead><tr><th>[抽象基类]</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputSreeam</td><td>Writer</td></tr></tbody></table></div><p>Java的IO流共设计40多个类，实际上非常规则，都是从以上4个抽象基类派生的。</p><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 </p><p><strong>InputStream 和 Reader 是所有输入流的基类</strong></p><h3 id="2-1-InputStream-典型实现：FileInpugStream"><a href="#2-1-InputStream-典型实现：FileInpugStream" class="headerlink" title="2.1 InputStream (典型实现：FileInpugStream)"></a>2.1 InputStream (典型实现：<strong>FileInpugStream</strong>)</h3><ul><li>int read()<br>在输入流中读取数据的下一个字节。返回0-255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回-1.</li><li><strong>int read(byte[])</strong><br>从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值为-1。否则<strong>以整数形式返回时机读取的字节数</strong> </li><li>int read(byte[],int off,int len)<br>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值为-1.   </li><li>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader。</li></ul><h3 id="2-2-Reader-典型实现：FileReader"><a href="#2-2-Reader-典型实现：FileReader" class="headerlink" title="2.2 Reader (典型实现：FileReader)"></a>2.2 Reader (典型实现：<strong>FileReader</strong>)</h3><ul><li>int read()<br>读取单个字符。作为整数读取的字符，范围在0-65535之间(0x00-0xffff)(2个字节的Unicode码),如果已到达流的末尾，则返回-1</li><li><strong>int read(char[] c)</strong><br>将字符读入数组。如果已到达流的末尾，则返回-1.否则返回本次读取的字符数</li><li>int read(char[] c,int off,int len)<br>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则饭hi本次读取的字符数。</li></ul><p><strong>OutputStream和Writer 是所有输出流的基类</strong></p><h3 id="2-3-OutPutStream"><a href="#2-3-OutPutStream" class="headerlink" title="2.3 OutPutStream"></a>2.3 OutPutStream</h3><ul><li>void write(int b)<br>将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。即写入0~255范围的。</li><li>void write(byte[] b)<br>将 b.length 个字节从指定的 byte 数组写入此输出流。write(b)的常规协定是：应该 与调用 write(b, 0, b.length) 的效果完全相同。</li><li>void write(byte[] b,int off,int len)<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 </li></ul><h3 id="2-4-Writer"><a href="#2-4-Writer" class="headerlink" title="2.4 Writer"></a>2.4 Writer</h3><ul><li>void write(int c)<br>写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。即 写入0 到 65535 之间的Unicode码。<ul><li>void write(char[] cbuf)<br>写入字符数组。</li><li>void write(char[] cbuf,int off,int len)<br>写入字符数组的某一部分。从off开始，写入len个字符</li><li>void write(String str)<br>写入字符串。</li><li>void write(String str,int off,int len)<br>写入字符串的某一部分。</li><li>void flush()<br>刷新该流的缓冲，则立即将它们写入预期目标。 </li></ul></li></ul><p>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件IO资源</strong></p><h2 id="三、节点流-或文件流"><a href="#三、节点流-或文件流" class="headerlink" title="三、节点流(或文件流)"></a>三、节点流(或文件流)</h2><p>直接从数据源或目的地读写数据</p><h4 id="3-1读取文件"><a href="#3-1读取文件" class="headerlink" title="3.1读取文件"></a>3.1读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.建立一个流对象，将已存在的一个我呢见加载进流</span></span><br><span class="line">FiileReader fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建有一个临时存放数据的数组</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用流对象的读取方法将流中的数据读入到数组中。</span></span><br><span class="line">fr.read(ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; </span><br><span class="line">    <span class="keyword">int</span> len; </span><br><span class="line">    <span class="keyword">while</span> ((len = fr.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">    System.out.println(<span class="string">"read-Exception :"</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            fr.close(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            System.out.println(<span class="string">"close-Exception :"</span> + e.getMessage();       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">#### 3.2 写入文件</span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建流对象，建立数据存放文件</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用流对象的写入方法，将数据写入流</span></span><br><span class="line">fw.write(<span class="string">"I hava a dream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流资源</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fw = <span class="keyword">new</span> FileWrtier(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line">    fw.write(<span class="string">"I hava a dream"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><ul><li>定义文件路径时，注意：可以用“/”或者“\”</li><li>在<strong>写入</strong>一个文件时，如果使用构造器FileOutputStream(file),则<strong>目录下有同名文件将被覆盖</strong></li><li>如果使用构造器FileOutputStream(file,true),则目录下的同迷宫文件不会被覆盖，<strong>在文件内容末尾追加内容</strong></li><li>在<strong>读取</strong>文件时，必须保证该文件已存在，否则报异常</li><li>字节流操作字节，比如：.mp3、.avi、.mp4、.jpg、.doc等</li><li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：txt、java、c、cpp等语言的额源代码。尤其注意doc、excel、ppt这些不是文本文件</li></ul><h2 id="四、处理流"><a href="#四、处理流" class="headerlink" title="四、处理流"></a>四、处理流</h2><p>不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序 提供更为强大的读写功能。</p><h3 id="4-1-缓冲流-处理流之一"><a href="#4-1-缓冲流-处理流之一" class="headerlink" title="4.1 缓冲流(处理流之一)"></a>4.1 缓冲流(处理流之一)</h3><ul><li><strong>为了提高数据读写的速度</strong>，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用 ==8192个字节(8kb)的缓冲区==</li></ul><p><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/buffer.png?raw=true" alt="buffer"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line">```  </span><br><span class="line">- 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为</span><br><span class="line">    - BufferedInputStream 和 BufferedOutputStream</span><br><span class="line">    - BufferedReader 和 BufferedWriter</span><br><span class="line">- 当读取数据时，数据按块读入缓冲区，其后的读操作直接访问缓冲区</span><br><span class="line">- 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件读取<span class="number">8192</span>(<span class="number">8</span>kb),存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个<span class="number">8192</span>个字节数组。</span><br><span class="line">- 向流中写入字节时，不会直接写道文件，先写道缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法**flush()**可以强制将缓冲区的内容全部写入输入流</span><br><span class="line">- 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外城流也会相应关闭内层节点流</span><br><span class="line">- flush()方法的使用：手动将buffer中内容写入文件</span><br><span class="line">- 如果是带缓冲区的流对象close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭不能再写出</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建缓冲流对象：它是处理流，是对节点流的包装</span></span><br><span class="line">      br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"d:\\IOTest\\source.txt"</span>)); </span><br><span class="line">      bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\IOTest\\d est.txt"</span>));</span><br><span class="line">      String str;</span><br><span class="line">      <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 一次读取字符文本文件的一行字符</span></span><br><span class="line">        bw.write(str); <span class="comment">// 一次写入一行字符串</span></span><br><span class="line">        bw.newLine(); <span class="comment">// 写入行分隔符</span></span><br><span class="line">      &#125; </span><br><span class="line">      bw.flush(); <span class="comment">// 刷新缓冲区</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭IO流对象</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">               bw.close(); <span class="comment">// 关闭过滤流时,会自动关闭它所包装的底层节点流</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123; </span><br><span class="line">               br.close();</span><br><span class="line">           &#125; </span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-转换流-处理流之二）"><a href="#4-2-转换流-处理流之二）" class="headerlink" title="4.2 转换流(处理流之二）"></a>4.2 转换流(处理流之二）</h3><p>转换流提供了字节流和字符流之间的转换<br><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/%E8%BD%AC%E6%8D%A2%E6%B5%81.png?raw=true" alt="zhuanhuan"><br>Java API提供了两个转换流：</p><pre><code>- InputStreamReader：将InputStream转换为Reader    **实现将字节的的输入流按指定字符集转换为字符的输入流。**    - 需要和InputStream“套接”    - 构造器        - public InputStreamReader(InputStream in)        - public InputStreamReader(InputStream in,String charsetName)- OutputStreamWriter：将Writer转换为OutputStream    **实现将字符的输出流按指定字符集转换为字节的输出流**    - 需要和OutputStream“套接”    - 构造器        - public OutputStreamWriter(OutputStream out)        - public OutputStreamWriter(OutputStream out,String charsetName)</code></pre><ul><li>字节流中的数据都是字符时，转成字符流操作更高效。</li><li>很多时候我们使用转换流来处理文件乱码问题。实现编码和节码的功能。</li></ul><h3 id="4-3-打印流-标准流之三）"><a href="#4-3-打印流-标准流之三）" class="headerlink" title="4.3 打印流(标准流之三）"></a>4.3 打印流(标准流之三）</h3><p>实现将<strong>基本数据类型</strong>的数据格式转换为<strong>字符串</strong><br>打印流：PrintStream和PrintWriter</p><ul><li>提供了一系列重载的print()和pringln()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应使用PrintWriter类。</li><li>System.out返回的是PrintStream的实例</li></ul><h3 id="4-4-对象流"><a href="#4-4-对象流" class="headerlink" title="4.4 对象流"></a>4.4 对象流</h3><p>ObjectInputStream和ObjectOutputStream</p><ul><li><p>用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p></li><li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p></li><li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本数据类型或对象的机制</p></li><li><p>ObjectOutStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p></li></ul><h3 id="4-5对象的序列化"><a href="#4-5对象的序列化" class="headerlink" title="4.5对象的序列化"></a>4.5对象的序列化</h3><ul><li><strong>对象的序列化机制</strong>允许把内存中的Java对象转化称平台无关的二进制流，从而把允许这种二进制流持久的保存在磁盘上，或通过网络将这中二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象</li><li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li><li>序列化时RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li><li>如果需要让两个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，则该类必须实现如下两个接口之一<ul><li><strong>Serializable</strong></li><li>Externlizable</li></ul></li><li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul><li>private static final long serialVersionUID;</li><li>serialVersionUID 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li><li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。<strong>若类的实例变量做了修改，serialVersionUID可能发生变化。</strong>故建议，显示声明。</li></ul></li><li>简单来说，Java的序列化机制是通过在运行是判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidcastException)</li></ul><h5 id="4-5-1-使用对象流序列化对象"><a href="#4-5-1-使用对象流序列化对象" class="headerlink" title="4.5.1 使用对象流序列化对象"></a>4.5.1 使用对象流序列化对象</h5><ul><li>若某个类实现了Serializable接口，该类的对象就是可序列化的：<ul><li>创建一个ObjectOututStream</li><li>调用ObjectoutputStream对象的writeObject(对象)方法输出可序列化对象</li><li>注意写一次，操作一次flush()</li></ul></li><li>反序列化<ul><li>创建一个ObjectInputStream</li><li>调用readObject()方法读取流中的对象<blockquote><p>如果某个类的属性不是基本数据类型或String类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类也不能序列化   </p></blockquote></li></ul></li></ul><p>序列化：将对象写入到磁盘或者进行网络传输。要求对象必须实现序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">Persion p = <span class="keyword">new</span> Per(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="string">"北京"</span>,<span class="keyword">new</span> Pet());</span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">反序列化：将磁盘中的对象数据源读出。</span><br><span class="line">```java</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">Persion p1 = (Persion)ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></p><blockquote><p>面试题<br>**谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其他人是吗？</p><ul><li>实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。<strong>这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异</strong>。换句话说，可以在Windows机器上创建一个对象，对其序列化 ，然后通过网络发给一台Unix机器，然后在那里准确无误地重新装配。不必关心数据在不同机器上如何表示，也不必关心字节地顺序或者其他任何细节。</li><li>由于大部分作为参数地类如String、Integer等都实现了Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</li></ul></blockquote><h4 id="4-5-2随机存取文件流-RadnomAccessFile类"><a href="#4-5-2随机存取文件流-RadnomAccessFile类" class="headerlink" title="4.5.2随机存取文件流 RadnomAccessFile类"></a>4.5.2随机存取文件流 RadnomAccessFile类</h4><p>我们可以用RandomAccessFile这个类，来实现一个<strong>多线程断点下载</strong>的功能，用过下载工具的朋友们都知道，下载前都会建立<strong>两个临时文件</strong>，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上次的地方下载，从而是按断点下载或上传的功能。</p><ul><li>读取文件内容<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(“test.txt”, “rw”);</span><br><span class="line">raf.seek(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">byte</span> [] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">5</span>;</span><br><span class="line">raf.read(b, off, len);</span><br><span class="line">String str = <span class="keyword">new</span> String(b, <span class="number">0</span>, len); System.out.println(str);</span><br><span class="line">raf.close();</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">- 写入文件内容</span><br><span class="line">```java</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>); raf.seek(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//先读出来 String temp = raf.readLine();</span></span><br><span class="line">raf.seek(<span class="number">5</span>); raf.write(<span class="string">"xyz"</span>.getBytes()); </span><br><span class="line">raf.write(temp.getBytes());</span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计一个有getMin功能的栈</title>
      <link href="/2019/07/23/getMinStack/"/>
      <url>/2019/07/23/getMinStack/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>实现一个特殊的栈，在实现栈的基本功能的基础上，在实现返回栈中最小元素的操作</p><h2 id="【要求】"><a href="#【要求】" class="headerlink" title="【要求】"></a>【要求】</h2><ol><li>pop、push、getMin操作的时间复杂度都是O(1).</li><li>设计的站的类型可以使用现成的栈结构。</li></ol><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>在设计时，我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData；另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体实现方式有两种。</p><h3 id="第一种设计方案"><a href="#第一种设计方案" class="headerlink" title="第一种设计方案"></a>第一种设计方案</h3><ol><li>压入规则<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空：<ul><li>如果为空，则newNum也压入stackMin。</li><li>如果不为空，则比较newNum和stackMin栈顶元素哪一个更小：<ul><li>如果newNum更小或者两者相同，则newNum也压入stackMin；</li><li>如果stackMin中栈顶元素小，则stackMin不压入任何元素；</li></ul></li></ul></li><li>弹出规则</li></ol><ul><li>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪个更小。</li><li>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素，返回value；</li></ul><ol><li>查询当前栈中的最小值<br>通过上文我们知道stackMin的栈顶元素一直记录着stackData的最小值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinStack1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetMinStack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二种设计方案"><a href="#第二种设计方案" class="headerlink" title="第二种设计方案"></a>第二种设计方案</h3><ol><li>压入规则</li></ol><ul><li>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<ul><li>如果为空，则newNum也压入stackMin；</li><li>如果不为空，则比较newNum和stackMin的栈顶元素哪一个更小。<ul><li>如果newNum更小或相等，则newNum压入stackMin；</li><li>如果stackMin中栈顶元素小，则把stackMin的栈顶元素重复压入stackMin中。</li></ul></li></ul></li></ul><ol><li>弹出规则<br>在stackData中弹出数据，弹出的数据记为value；弹出stackMin的栈顶元素，返回value。</li><li>查询当前栈中最小值<br>由上文的规则可知，stackMin栈顶元素始终记录着stackData中的最小值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinStack2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetMinStack2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackMin.isEmpty()) &#123;</span><br><span class="line">            stackMin.push(newNum);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum &lt;= <span class="keyword">this</span>.getMin())&#123;</span><br><span class="line">            stackMin.push(newNum);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newMin = stackMin.peek();</span><br><span class="line">            stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackData.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="【点评】"><a href="#【点评】" class="headerlink" title="【点评】"></a>【点评】</h2><p>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点时所有操作的时间复杂度都为O(1)、空间复杂度都为O(n)。区别是：方案一种stackMin压入稍省时间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础——自增变量</title>
      <link href="/2019/07/22/selfadd/"/>
      <url>/2019/07/22/selfadd/</url>
      
        <content type="html"><![CDATA[<h2 id="自增-：将变量的值加-1"><a href="#自增-：将变量的值加-1" class="headerlink" title="自增 (++) ：将变量的值加 1"></a>自增 (++) ：将变量的值加 1</h2><ol><li>前缀式：如 ++i。前缀式是先加1再使用。</li><li>后缀式：如 i++。后缀式是先使用再加1。</li></ol><h2 id="自减-—-将变量的值减-1"><a href="#自减-—-将变量的值减-1" class="headerlink" title="自减 (—) : 将变量的值减 1"></a>自减 (—) : 将变量的值减 1</h2><ol><li>前缀式：如 —i。前缀式是先减1再使用。</li><li>后缀式：如 i—。后缀式是先使用再减1。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面我们来看一个例题，如果你能很轻易的算出结果，估计本文对你帮助不太大了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       i = i++;</span><br><span class="line">       <span class="keyword">int</span> j = i++;</span><br><span class="line">       <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">       System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">       System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i = 4</span><br><span class="line">j = 1</span><br><span class="line">k = 11</span><br></pre></td></tr></table></figure></p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>我们来分析一下运算过程<br><img src="/2019/07/22/selfadd/selfadd.jpg" alt="add"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>赋值 = ，最后计算</li><li>=右边的从左到右加载值依次<strong>压入操作数栈</strong></li><li>实际先算哪个，看运算符优先级</li><li>自增、自减操作都是直接修改便俩个的值，不经过操作数栈</li><li>最后的赋值之前，临时结果也是存储在操作数栈中</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 自增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(四)类文件结构</title>
      <link href="/2019/07/18/JVM4/"/>
      <url>/2019/07/18/JVM4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在Java中，JVM可以理解的代码叫做==字节码==(及 .class文件)。Java语言通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效。</p><h2 id="Class文件结构总结"><a href="#Class文件结构总结" class="headerlink" title="Class文件结构总结"></a>Class文件结构总结</h2><p>Class文件是一组以8位字节为基础单位的二进制流。Class文件格式采用一种类似与C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、两个字节、4个字节和8个字节的无符号数，无符号数 可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯地以“_info”结尾。整个Class文件本质上就是一张表，它由一下所示地数据项构成。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1 </td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods</td><td>methods_count</td></tr><tr><td>methods_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table></div><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个Class文件的头四个字节称为魔数(Magic Nuber),它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4      magic; <span class="comment">//Class文件的标志</span></span><br></pre></td></tr></table></figure></p><h3 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h3><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5个和第6个字节是次版本号(Mainor Version),第7和第8个字节是主版本号(Major Version).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2      minor_version;<span class="comment">//Class的次版本号</span></span><br><span class="line">u2      major_sersion;<span class="comment">//Class的主版本号</span></span><br></pre></td></tr></table></figure></p><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主次版本号之后的是常量池，常量池的数量是constant_pool_count-1（常量池计数器是从1开始计数的，<strong>索引为0代表不引用任何一个常量池项</strong>)<br>常量池主要存放两大类长量：字面量和符号引用。字面量比较接近于Java与语言层面的常量的概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符<br>常量池中每一项常量都是一个表，这14中表有一个共同特点：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量术语那种类型常量。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td><td>表示有一个动态方法调用点</td></tr></tbody></table></div><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束后，紧接着的两个字节代表访问标志(access_flags),这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。<br>类访问和属性修饰符：<br>标志名称 | 标志值 | 含义<br>— | — | —<br>ACC_PUBLIC | 0x0001 | 是否为public类型<br>ACC_FINAL | 0x0010 | 是否被声明为final，只有类可设置<br>ACC_SUPER | 0x0020 | 是否允许使用invokespecial字节码指令的新语意<br>ACC_INTERFACE | 0x200 | 标志这是一个接口<br>ACC_ABSTRACT | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假<br>ACC_SYNTHETIC | 0x1000 | 标识这个类并非由用户代码产生的<br>ACC_ANOTATION | 0x2000 | 标识这是一个注释<br>ACC_ENUM | 0x4000 | 标识这是一个枚举</p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个雷可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多继承，索引父类索引只有一个，除了==java.lang.Object==之外，所有的Java类都有父类，因此除了==java.lang.Object==外。</p><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按==implements==语句(如果这个类本身是一个接口，则应当是extends)后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表(field info) 用于描述接口或类中声明的标量。字段保罗类级别变量以及实例变量，但不包括在方法内部声明的局部变量。<br>字段表结构：</p><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>作用</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td><td>字段的作用域，是实例变量还是类变量(static修饰符)，可否被序列化(transient修饰符),可变性(final)，可见性(volatile)</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>对常量池的引用，表示的字段的名称</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td><td>对常量池的引用，表示字段和方法的描述</td></tr><tr><td>u2</td><td>attributes</td><td>1</td><td>存放具体属性内容</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>一个字段还会拥有一些额外的属性，用来存放属性的个数</td></tr></tbody></table></div><p>字段的access_flags的取值</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private </td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否pritected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FIANL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生的</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table></div><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p>Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1 </td></tr><tr><td>u2</td><td>descriptor_index</td><td>1 </td></tr><tr><td>u2</td><td>attributes</td><td>1 </td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table></div><p>方法的access_flags的取值</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否private </td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否pritected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FIANL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器自动产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x1000</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x4000</td><td>方法是否为Abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x8000</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生的</td></tr></tbody></table></div><p>方法里的Java代码，经过编译器编译称字节码指令后，存放在方法属性中一个名为“code”的属性里面。</p><h3 id="属性标集合"><a href="#属性标集合" class="headerlink" title="属性标集合"></a>属性标集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在Class文件、字段表、方法表、都可以携带字节的属性表集合，以用于描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了些，不再要求各个属性具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以像属性表中写入自己定义的属性信息。Java虚拟机运行时会忽略掉他不认识的属性。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(三)虚拟机性能监控与故障处理工具</title>
      <link href="/2019/07/18/JVM3/"/>
      <url>/2019/07/18/JVM3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>这些命令在JDK安装目录的bin目录下<br>名称 | 主要作用<br>—   | — |<br>jps  | JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程<br>jstat | JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据<br>jinfo | Configuration Info for Java，显示虚拟机配置信息<br>jmap | Memory Map for Java，生成虚拟机的内存转储快照<br>jhat | JVM Heap Dump Browser,用于分析heapdump文件，他会建立一个HTTP/HTML服务器，让用户可以i在浏览器查看分析结果<br>jstack | Stack Trace for Java，显示虚拟机的线程快照</p><h3 id="jps-查看所有Java进程"><a href="#jps-查看所有Java进程" class="headerlink" title="jps:查看所有Java进程"></a>jps:查看所有Java进程</h3><p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID(LVMID)</p><h4 id="jps命令格式"><a href="#jps命令格式" class="headerlink" title="jps命令格式"></a>jps命令格式</h4><p>jps [options] [hostid]</p><p>jps工具主要选项<br>选项    |   作用<br>—  |   —<br>-q  |   只输出LVMID，省略主类的名称<br>-m  |   输出虚拟机 进程启动时传递给主类main()函数的参数<br>-1  |   输出主类的全名，如果进程执行的是jar包，输出jar包路径<br>-v  |   输出虚拟机进程启动时JVM参数</p><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>用于监视虚拟机各种运行状态信息的命令工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><h4 id="jstat命令格式"><a href="#jstat命令格式" class="headerlink" title="jstat命令格式"></a>jstat命令格式</h4><p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]] </count></interval></vmid></lines></option></p><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类加载所消耗的时间</td></tr><tr><td>-gc</td><td>监视Java堆状态，包括Eden区、两个Survivor、老年代、永久代等的容量、已用空间、GC时间合计等信息。</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC情况</td></tr><tr><td>-gcnewcapcity</td><td>监视内容与-gcnew基本相同，但主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代GC状态</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的额最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-complier</td><td>输出JIT编译器编译过的方法，耗时信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table></div><h3 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h3><p>实时查看和调整虚拟机各项参数</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>jinfo [option] pid</p><ul><li>jinfo -vmid:输出对应名称的参数的具体值。比如输出MaxHeapSize、查看当前jvm进程是否开启打印GC日志。</li><li>jinfo -flag [+ | -]name vimd 开启或者关闭对应的名称的参数<br>使用此命令可以在不开启虚拟机的情况下，可以动态的修改jvm的参数。尤其是线上的环境特别有用。</li></ul><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>用于生成堆转储块照。如果不使用jmap命令，要想获取Java堆转储快照，还可以使用“-XX：HeapDumpOnOutOfMemoryErroy”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令可以通过“kill -3”发送进程退出信号也能拿到dump文件。<br>jmap的作用不仅仅是为了获取dump文件，它还可以查询finalizer执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。</p><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>与jmap搭配使用，来分析jmap生成的堆转储快照。它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。</p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><h4 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h4><p>jstack [option] vmid<br>option 选项<br>选项 | 作用<br>— | —<br>-F | 当输出的请求不被响应时，强制输出线程堆<br>-l | 除堆栈外，显示关于锁的附加信息<br>-m | 如果调用到本地方法的话，可以显示C/C++的堆栈</p><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>是一种基于JMX的可视化监视、管理工具。可以很方便的监视本地及远程服务器的java进程的内存使用情况。你可以在控制台输出console命令启动或者在JDK目录下的bin目录找到jconsole.exe启动。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(二)垃圾收集器与内存分配策略</title>
      <link href="/2019/07/18/JVM2/"/>
      <url>/2019/07/18/JVM2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>人们早期就在思考GC需要完成的3件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><blockquote><p>当我们需要排查各种内存溢出、内存泄漏问题时、当垃圾收集成为系统达到更高并发量的瓶颈时，，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p></blockquote><h3 id="1-JVM内存分配与回收"><a href="#1-JVM内存分配与回收" class="headerlink" title="1. JVM内存分配与回收"></a>1. JVM内存分配与回收</h3><p>Java的自动你内存管理主要时针对对象内存的回收和对象内存的分配。同时，Java内存管理最核心的功能时<strong>堆</strong>内存中对象的分配与回收。</p><p>Java堆是垃圾回收器管理的主要区域，因此也被称为<strong>GC堆</strong>。从垃圾回收的角度，由于现在收集器基本采用分代垃圾收集算法，所以Java 堆海口可以细分为：新生代和老年代；再细致一点有：Eden空间、From Surivior、To Survior空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存</strong>。</p><h4 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h4><p><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%A0%86%E7%A9%BA%E9%97%B4.jpg?raw=true" alt="堆空间"></p><ul><li>新生代：eden区、s0(From)区、s1(To)</li><li>老年代: tentired区</li></ul><p>大部分情况，对象都会首先再eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s1,并且对象的年龄还会加1(eden区-&gt;Surrvior区后对象的初始年龄变为1)，当它的年龄增加到一定程度(默认15),就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 ==-XX:MaxTenuringThreshold== 来设置。经过这次GC后，eden区和“From”区已经被清空。这个时候“From”和“To”会交换他们的角色，就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor FC会一直重复这样的过程，直到”To”区被填满之后，会将所有对象移动到老年代中。</p><h4 id="堆内存常见分配策略"><a href="#堆内存常见分配策略" class="headerlink" title="堆内存常见分配策略"></a>堆内存常见分配策略</h4><ul><li>对象优先在eden区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul><h5 id="对象优先在eden区分配"><a href="#对象优先在eden区分配" class="headerlink" title="对象优先在eden区分配"></a>对象优先在eden区分配</h5><p>目前主流的垃圾回收器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>Minor GC和Full GC的区别</strong></p><ul><li>新生代 GC(Minor GC): 指发生新生代的垃圾回收收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li>老年代 GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC(并非绝对),Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一下方式运行：<br><img src="https://camo.githubusercontent.com/2713b77464413e9aeb63cdd9d8cd198cb3fea34a/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32353137383335302e6a7067" alt="run"></p><p>添加参数：==-XX:+PrintGCDetails==</p><p><img src="https://camo.githubusercontent.com/9c349ba9ea4778b4c5f7cd0fb7e7efd812902330/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f31303331373134362e6a7067" alt="run"></p><p>运行结果：</p><p><img src="https://camo.githubusercontent.com/42464b598a233d4319009cc06e3d199b6331c314/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383935343238362e6a7067" alt="run"></p><p>从上图我们剋看出eden区内存几乎已经被分配完全(即使程序什么也不做，新生代也会使用20000多k内存)。假如我们再为allocation2分配内存会出现什么情况呢？</p><p><img src="https://camo.githubusercontent.com/215514817e1b01cd89ba942c382d2f64cb6c9e3d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383132383738352e6a7067" alt="run"></p><p><strong>解释一下为什么会出现这种情况</strong>：因为给allcation2分配内存的时候eden区内存几乎被分配完了，我们刚刚讲了eden区没有足够空间进行分配时，虚拟机将放弃一次Minor GC。GC 期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能狗仔eden区的话，还是会在eden区分配内存。</p><blockquote><p>空间分配担保<br>在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC 可以确保是安全地。</p></blockquote><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>所谓大对象是指需要大量连续内存空间的Java对象，如数组、字符串。<br>这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制(新生代采用复制算法收集内存)而降低效率。</p><h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>既然虚拟机才有用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。</p><p>如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并且能被Survivor容纳的话，将被移动Survivor空间中，并将对象年龄设为1。对象在Survivor区没每熬过一次Minor GC ，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁)，就会将被晋身到老年代中。对象晋升老年代的年龄阈值，可以通过参数==-XX:MaxTenuringThreshold== 设置</p><h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><p>为了能更好的使用不同程序的内存状态，虚拟机并不是永远地要求年龄必须达到MaxTenuringThreshold才能晋升为老年代，如果在Survivor空间相同年龄所有对象地总和大于Survivor空间地一半，年龄大于或等于该年龄地对象就可以直接进入老年代，无需等到要求年龄。</p><h4 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h4><p>堆中几乎存放着所有对象地实例，对垃圾回收前地第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用地对象)</p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对昂中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p><strong>这个算法实现简单，判定效率高，在大部分情况下他都是一个不错的算法。但是目前主流的虚拟机并没有选择这个算法来管理内存，其最主要的原因时它很难解决对象之间相互循环引用的问题。</strong></p><blockquote><p>举个例子:对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA,除此之外，这两个对象再无任何的引用，实际上这两个对象已经不可能在被访问，但是他们也因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ReferenceCountingGC ogjA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC ogjB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则证明对象不可用。<br><img src="https://camo.githubusercontent.com/6c6a9c7e2a7849cab8d5966ec1916115380e2842/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f37323736323034392e6a7067" alt="keda"></p><h5 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h5><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。JDK1.2以后，Java对引用概念呢进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>(引用强度逐渐减弱)</p><h6 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h6><p>指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><h6 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h6><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><h5 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h5><p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联对象。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存周期构成影响，也无法通过虚引用来取得一个对象实例。唯一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><blockquote><p>在程序设计中一般很少使用弱引用和虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，放置内存溢出等问题的产生。</strong></p></blockquote><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，<strong>至少要经历两次标记过程</strong>：如果对象在进行可达分析后发现没有与GC Roots 相连接的引用链，那它将会被第一次标记且进行一次筛选，筛选条件是此对此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都是为“没有必要执行”。</p><p>被判定为需要执行的对象将会放置在一个叫做F-Queue的队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li>标记-清除算法</li><li>复制算法</li><li>标记算法</li><li>分代收集算法</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>该算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它主要不足有两个：</p><ol><li>效率问题：标记和清除两个过程的效率都不高</li><li>空间问题：标记清除后会产生大量不连续的内存碎片。<br><img src="https://camo.githubusercontent.com/dc1f798e7c7f9aa9a3ab692db10a6b1788e5d505/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f36333730373238312e6a7067" alt="baioji"></li></ol><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题,“复制”收集算法出现了，它将可用内存按照容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收。<br><img src="https://camo.githubusercontent.com/94cfc5e1fbe9d49b3ed056d2943fd86dac1833a2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39303938343632342e6a7067" alt="copy"></p><p>目前主流的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象要一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的地Survivor空间 (HotSpot虚拟机默认Eden和Survivor地大小比例是8：1);</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代地特点推出地一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以为的内存。</p><p><img src="https://camo.githubusercontent.com/e5223ec7b2460498e1934c14eeaf969bafdcab59/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39343035373034392e6a7067" alt="bz"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集。这种算法没有什么新的思想，只是根据对象存活周期将内存分为几块。一般将Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点采用最适当的收集算法了。<strong>在新生代中，每次垃圾收集时都发现那个有大批量对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</strong></p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实。</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial(串行)收集器是最基本、历史最悠久的垃圾收集器。是一个<strong>单线程</strong>收集器。它的单线程意义不仅仅以为着它只会使用一条垃圾收集线程完成垃圾收集工作，更重要的是它在进行垃圾收集器工作的时候必须暂停其他所有的工作线程(“Stop The World”)，直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong><br><img src="https://camo.githubusercontent.com/aba41c5c08ea9884554b9a69ea69c7ceeebc83ff/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f34363837333032362e6a7067" alt="ser"></p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Servial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、huishoucelue)和Serial收集器完全一样。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong><br><img src="https://camo.githubusercontent.com/f298ba56ec4667487fdf4acc987f2ef9e6df254e/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f32323031383336382e6a7067" alt="par"></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有他能与CMS收集器(真正意义上的并发收集器)配合工作。</p><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>Parallel Scavenge 收集器也是四好用复制算法的多线程收集器，它看上去几乎和ParNew都以一样。那它有什么特别之处呢？</p><p>Parallel Scavenge 收集器 关注点是吞吐量(高效率的利用给CPU).CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间(提升用户体验)。</p><blockquote><p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p></blockquote><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量</p><ol><li>-XX:MaxGCPauseMillis<br> 控制最大垃圾收集停顿时间</li><li>-XX:GCTimeRatio<br> 直接设置吞吐量大小</li></ol><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。使用标记-整理算法。这个收集器的主要意义也是在于Client模式下的虚拟机使用。</p><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><p>Parallel Scavenge 收集器的老年代版本。使用多线程和标记整理算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和parallel Old 收集器。</p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>CMS收集器是一种获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现，它的运作过程相对于前面几种收集器来说更复杂一些，分为4个步骤：</p><ul><li>初始标记：仅仅之际标记一下GC Roots能直接关联到的对象，速度很快；</li><li>并发标记：进行GC Roots Tracing的过程。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</li><li>并发清除：开启用户线程，同时GC 线程开始对为标记的区域进行清扫。</li></ul><p><img src="https://camo.githubusercontent.com/d74545af0f987d17b7f41a60bb237a113fff925b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f38323832353037392e6a7067" alt="cms"></p><p>CMS收集器主要优点：并发收集、低停顿。但是它有一下3个明显的缺点：</p><ul><li>对CPU 资源非常敏感；</li><li>无法处理浮动垃圾；</li><li>使用标记-清除算法 导致收集结束时会有大量空间碎片产生。</li></ul><h5 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h5><p>G1 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以及高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。它具备以下特点：</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU(或者CPU核心)来缩短Stop-The-World停顿的时间，</li><li>分代收集：分代概念在G1收集器中得以保留，虽然G1可以不需要其他收集器配合就能独立管理整个GC堆。</li><li>空间整合：与CMS的标记-情理算法不同，G1从整体来看是基于标记整理算法实现的收集器，从局部来看是基于复制算法实现的。</li><li>可预测的停顿：这是G1相对与CMS的另一个大优势，降低停顿时间G1和CMS共同的关注点，但G1除了追求停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间段内。</li></ul><p>G1收集器的运作分为一下一个步骤</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的手机效率(把内存化整为零)。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(五)虚拟机类加载机制</title>
      <link href="/2019/07/18/JVM5/"/>
      <url>/2019/07/18/JVM5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称连接。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg?raw=true" alt="leijiazai"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，但是解析阶段不一定：它再某些情况下可以再初始化阶段之后再开始。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段需要完成3件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。</li></ol><p><strong>一个非数组类的加载阶段(加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，可以通过定义自己的类加载器去控制字节流的获取方式(既重写一个类加载器的loadClass()方法)。</strong></p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的：为了确保Class文件的字节流中包含的信息符合当前虚拟机的有要求，而且不会危害虚拟机自身的安全。</p><ol><li>文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br>例如: <ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否由不被支持的常量类型(检查常量tag标志)<br>…</li></ul></li><li>元数据验证<br>对自己吗描述的信息进行语义分析，以确保其描述的信息符合Java语言规范的要求<ul><li>这个类是否由父类(除了java.lang.Object之外，所有的类都应当由父类)</li><li>这个类的父类是否继承了不允许被继承的类(被final修饰)<br>…</li></ul></li><li>字节码验证<br>最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的<ul><li>保证任意时刻操作栈的数据类型与指令代码序列都能配合工作</li><li>保证跳栈指令不会跳转到方法体以外的字节码指令上<br>…</li></ul></li><li>符号引用验证<br>发生在虚拟机将符号引用转化为直接引用的时候，符号引用验证可以看作是对类自身意外(常量池中的各种符号引用)的信息进行匹配校验<ul><li>符号引用中同故宫字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符号方法的字段描述以及简单名称所描述的方法和字段</li></ul></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下：</p><ol><li>这时候进行内存分配的仅包括类变量(static修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为==public static int value = 123==那变量value在准备阶段过后的初始值为0而不是123，因为这时还未开始执行任何Java方法(赋值动作将在初始化阶段才会之心那个)。“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量value会被初始化为ConstatnValue所指定的值。假设上面类变量value的定义为==public static final int value = 123==那么主备阶段value值为123。</li></ol><p>基本数据类型的零值<br>数据类型 | 零值<br>— | —<br>int | 0<br>long | 0L<br>short | (short)0<br>char | ‘\u0000’<br>byte | (byte)0<br>boolean | false<br>float | 0.0f<br>double | 0.0d<br>reference | null</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用：可以是直接指向目标地指针、相对偏移量或是一个能间接定位到目标地句柄。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程地最后一步，才是真正开始执行类中定义的Java程序代码(或者说是字节码)<br>初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p><ul><li><clinit>()方法是由于编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中语句合并产生的，编译器收集的顺序是由语句在源文件中出席那的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问；</clinit></li><li><clinit>()方法与类的构造函数不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。</clinit></clinit></clinit></li><li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></li><li><clinit>()方法对于类和接口并不是必需的，如果一个类中没有静态语句块，也就没有对变量的赋值操作，就不会为这个类生成<clinit>()方法。</clinit></clinit></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>启动类加载器(Bootstrap ClassLoader): 这个类加载器使用C++语言实现，是虚拟机自身的一部分。负责将存放在<java_home> \lib目录中的，或者被-Xbootclasspath擦书所指定的路径中的类库加载到虚拟机内存中。</java_home></li><li>扩展类加载器(Extension ClassLoader): 负责加载<java_home>/lib/ext目录中的，或者被java.ext.dirs系统变量指定的路径中的所有类库。</java_home></li><li>应用程序类加载器(Application ClassLoader): 负责加载用户类路径(ClassPath)上指定的类库</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。一般使用组合(Copmposition)关系来服用父类加载的代码。<br><img src="https://camo.githubusercontent.com/4311721b0968c1b9fd63bdc0acf11d7358a52ff6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f636c6173736c6f616465725f5750532545352539422542452545372538392538372e706e67" alt="shuagnqin"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，源代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，在调用自己的findzClass()方法进行加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">           <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一)Java内存区域与内存溢出异常</title>
      <link href="/2019/07/18/JVM1/"/>
      <url>/2019/07/18/JVM1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不在需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出的问题。不过正是因为将内存的控制权力交给了java虚拟机，一旦出现内存的泄露和溢出方面的问题，如果不了解虚拟机是怎么使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><p>JDK 1.8:<br><img src="https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67" alt="jvm内存模型"></p><h3 id="线程私有的"><a href="#线程私有的" class="headerlink" title="线程私有的"></a>线程私有的</h3><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈<h3 id="线程共享的"><a href="#线程共享的" class="headerlink" title="线程共享的"></a>线程共享的</h3></li><li>堆</li><li>方法区</li><li>直接内存(非要运行时数据区的一部分)<h3 id="2-1程序计数器"><a href="#2-1程序计数器" class="headerlink" title="2.1程序计数器"></a>2.1程序计数器</h3>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当线程所执行的字节码的行号指示器。<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></li></ul><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><blockquote><p>程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryErroy情况的区域。</p></blockquote><h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><blockquote><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></blockquote><p>Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p><blockquote><p>实际上，Java虚拟机栈是由一个个栈帧组成，每个栈帧中都拥有：局部变量、操作数栈、动态链接、方法出口信息</p></blockquote><p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</p><p>Java虚拟机栈规定了两种异常情况：StackOverFlowError和OutOfMemoryError</p><ul><li>StackOverFlowError：如果下称请求的栈深度大于虚拟机所允许的深度，则抛出此异常。</li><li>OutOfMemoryError：如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，就会抛出磁异常。<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3>本地方法栈与虚拟机栈所发挥的作用非常相似，区别是:</li><li>虚拟机栈为虚拟机执行Java方法(也就是字节码 )服务</li><li>本地方法栈则为虚拟机使用到的Native方法服务。</li></ul><blockquote><p>在Sun  HotSpot虚拟机中把本地方法栈和虚拟机栈合二为一。</p></blockquote><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>与虚拟机栈中一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError两种异常。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p><p>Java堆时垃圾收集器管理的主要区域，因此很多时候被称为<strong>GC堆。</strong>从内存回收的角度看，由于现在收集器基本都采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为：<strong>新生代和老生代</strong>；再细致一点的有：Eden空间、From Survivor空间、To Survivor空间等。<strong>进一步划分的目的是为了更好地回收内存，或者更快的分配内存</strong></p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一逻辑部分，但是它有个别名<strong>Non—Heap(非堆)</strong>，目的应该时与Java堆区分开来。</p><p><strong>在JDK1.8的时候，方法区被彻底移除了，取而代之是元空间，元空间使用的是之际内存。</strong><br>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSIze=N  //设置Metaspace的初始(和最小)大小</span><br><span class="line">-XX:MaxMetaspaceSize=N  //设置Metaspace的最大大小</span><br></pre></td></tr></table></figure></p><h4 id="2-5-1-为什么要将永久代-PerGen-替换元空间-MetaSpace-呢？"><a href="#2-5-1-为什么要将永久代-PerGen-替换元空间-MetaSpace-呢？" class="headerlink" title="2.5.1 为什么要将永久代(PerGen)替换元空间(MetaSpace)呢？"></a>2.5.1 为什么要将永久代(PerGen)替换元空间(MetaSpace)呢？</h4><p>整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存呢的限制，并且永远不会得到Java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为unlimited，这意味着它只受系统内存的限制， -XX:MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则Metaspace将根据运行时的应用程序需求动态地重新调整大小。</p><h3 id="2-6-运行时常量"><a href="#2-6-运行时常量" class="headerlink" title="2.6 运行时常量"></a>2.6 运行时常量</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(用于存放编译器生成的各种字面量和符号引用)</p><p>**JDK 1.7及以后版本的JVM已经将运行是常量池从方法区移了出来，在Java中开辟了一块区域存放运行时常量。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/yunxing.png?raw=true" alt="常量池"></p><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用</strong></p><p>JDK 1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据。</p><p>本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻找空间的限制</p><h2 id="3-HotSpot-虚拟机对象探秘"><a href="#3-HotSpot-虚拟机对象探秘" class="headerlink" title="3. HotSpot 虚拟机对象探秘"></a>3. HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解下HtoSpot虚拟机在Java堆中对象的分配、布局和访问的全过程。</p><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下面便是Java 对象创建过程。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.jpg?raw=true" alt="对象的创建"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须限制性想要赢得类加载过程。</p><h4 id="Stept2：分配内存"><a href="#Stept2：分配内存" class="headerlink" title="Stept2：分配内存"></a>Stept2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，虚拟机将为新生对象<strong>分配内存</strong>。对象所需内存的大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<strong>分配方式</strong>有“<strong>指针碰撞</strong>”和“<strong>空闲列表</strong>”两种，<strong>选择那种分配方式由Java堆是否规整决定，而Java堆是否规整右由所曹勇的垃圾收集器是否带有压缩整理功能决定。</strong></p><h5 id="内存分配的两种方式："><a href="#内存分配的两种方式：" class="headerlink" title="内存分配的两种方式："></a>内存分配的两种方式：</h5><p>选择以上两种分配方式由Java堆是否规整决定，而Java堆内存是否规整，取决于GC收集器的算法是”标记-清除”，还是”标记-整理”(也称作”标记-压缩”),值得注意的是，复制算法内存也规整的<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png?raw=true" alt="内存分配"></p><h5 id="内存分配并发问题："><a href="#内存分配并发问题：" class="headerlink" title="内存分配并发问题："></a>内存分配并发问题：</h5><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在时机开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式保证线程安全：</p><ul><li>CAS + 失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁二十假设没有冲突而去完成某项操作，如果因为冲突失败就重试，知道成功为止。<strong>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</strong></li><li>TLAB：为每一个线程预先在Eden区分配一块内存，JVN在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h4 id="Step3：初始化零值"><a href="#Step3：初始化零值" class="headerlink" title="Step3：初始化零值"></a>Step3：初始化零值</h4><p>内存分配完成后，虚拟机需要要将分配到的内存空间都初始化为零值(不包括对象头)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4：设置对象头"><a href="#Step4：设置对象头" class="headerlink" title="Step4：设置对象头"></a>Step4：设置对象头</h4><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息存放在对象头中</strong>。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不用的设置方式。</p><h4 id="Step-执行init方法"><a href="#Step-执行init方法" class="headerlink" title="Step:执行init方法"></a>Step:执行init方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建 才刚刚开始——<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可以用的对象才算完全产生出来。</init></init></p><h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在HotSpot虚拟机中，对下个在内存中存储的布局可以分为3块<strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong></p><p>HotSpot虚拟机中的对象头包括两部分信息：</p><ul><li>用于存储对象自身的的运行时数据(如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等)。</li><li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对其填充部分不是必然存在的，也没有什么特别的意义，仅仅起占位作用</strong>。因为HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的倍数,因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我么的Java程序通过栈上的reference的数据来操作堆上的具体对象.对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ol><li><p>句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br><img src="https://camo.githubusercontent.com/04c82b46121149c8cc9c3b81e18967a5ce06353f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545342542442542462545372539342541382545352538462541352545362539462538342e706e67" alt="jubing"></p></li><li><p>直接指针：如果使用直接针织访问，那么Java堆对象的布局中就必须考虑如果放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址，<br><img src="https://camo.githubusercontent.com/0ae309b058b45ee14004cd001e334355231b2246/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545372539422542342545362538452541352545362538432538372545392539322538382e706e67" alt="zhizhen"></p></li></ol><p><strong>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>母牛生小牛</title>
      <link href="/2019/07/17/NumOfCow/"/>
      <url>/2019/07/17/NumOfCow/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。第一年农场只有一只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛3年成熟后又可以生小母牛。给定整数N，求出N年后牛的数量。</p><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>所有的牛都不会死，所以第N-1年的牛会毫无损失的活到第N年。同时所有成熟的牛都会生1头小牛，那么成熟的牛数量如何估计？就是第N-3年的所有牛，到第N年肯定是成熟的牛，期间出生的牛肯定没有成熟。所以C(n) = C(n-1)+C(n-3),初始项C(1)==1,C(2)==2，C(3)==3。这个和斐波那契数列数列十分相似，只不过C(n)依赖C(n-1)和C(n-3)的值</p><h3 id="方法一-O-2-N"><a href="#方法一-O-2-N" class="headerlink" title="方法一  O(2^N^)"></a>方法一  O(2^N^)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">c1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> c1(n - <span class="number">1</span>) + c1(n - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法-O-N"><a href="#方法-O-N" class="headerlink" title="方法  O(N)"></a>方法  O(N)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">c2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            tmp1 = res;</span><br><span class="line">            tmp2 = pre;</span><br><span class="line">            res = res + prepre;</span><br><span class="line">            pre = tmp1;</span><br><span class="line">            prepre = tmp2;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
