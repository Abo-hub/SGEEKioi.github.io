<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>头条搜索APP产品体验</title>
      <link href="/2020/03/06/%E5%A4%B4%E6%9D%A1%E6%90%9C%E7%B4%A2APP%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/03/06/%E5%A4%B4%E6%9D%A1%E6%90%9C%E7%B4%A2APP%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、产品体验环境"><a href="#一、产品体验环境" class="headerlink" title="一、产品体验环境"></a>一、产品体验环境</h2><p>《头条搜索》软件版本: V7.2.5.0<br>《百度》软件版本：V 11.20.14<br>《今日头条》软件版本：V 7.6.3</p><p>设备型号：华为P10</p><p>操作系统：EMUI9.1.0 基于Android 9</p><p>体验时间：2020年3月2日</p><h2 id="二、产品简介："><a href="#二、产品简介：" class="headerlink" title="二、产品简介："></a>二、产品简介：</h2><p>上架时间：2020/2/21<br>应用介绍：《头条搜索》提供及时、高质量的综合搜索功能以及丰富的热点、资讯、视频内容，当您在遇到问题时，快速帮你找到答案，助您解决问题。<br>应用标签：<code>实用工具</code> <code>浏览器</code></p><blockquote><p>以上信息来源 华为应用商店</p></blockquote><p>经过半年时间的测试，字节跳动于2020/2/21日上线了《头条搜索》独立App。其产品全新slogan为“头一条就是你想搜的”。目前在安卓的应用市场可以下载，不过ios 暂时还不可以下载。</p><!-- <img src="/头条搜索APP产品体验/ttslogn.jpg"/> (开屏页面) --> <!-- <img src="/头条搜索APP产品体验/ttindex3.jpg"/><img src="/头条搜索APP产品体验/ttvideo.jpg"/><img src="/头条搜索APP产品体验/ttvideo2.jpg"/><img src="/头条搜索APP产品体验/ttmine.jpg"/> --><p>在应用商店的应用标签我们可以看出，《头条搜索》定位是一款<code>浏览器</code>。通过对比《百度》，发现两者的设计十分相似，底部导航都是“首页”、“视频”、“小视频”、“个人中心”，并且都是采用搜索框+信息流的的模式。《头条搜索》整体的界面设计更像是一个精简版的《今日头条》，重新组合了部分业务。</p><p><img src="/2020/03/06/头条搜索APP产品体验/ttindex3.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttvideo4.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttvideo2.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttmine.jpg"></p><h2 id="三、功能体验"><a href="#三、功能体验" class="headerlink" title="三、功能体验"></a>三、功能体验</h2><h3 id="1、搜索功能"><a href="#1、搜索功能" class="headerlink" title="1、搜索功能"></a>1、搜索功能</h3><h4 id="1-1-搜索入口"><a href="#1-1-搜索入口" class="headerlink" title="1.1 搜索入口"></a>1.1 搜索入口</h4><p>《头条搜索》共有两个搜索入口，分别是首页的搜索框和视频页的搜索框。在功能上是相同的，在没有点击搜索框时，会根据算法生成的猜你喜欢话题滚动播放。</p><p>搜索页分为三个部分，最上方根据算法生成的推荐搜索话题(滚动播放内容)；中间部分显示6条“历史记录”，点击“删除图标”，最多显示20条历史记录，并显示相关删除操作；最下方显示热门的话题；</p><p>在编辑搜索内容时，可以看出历史搜索的词条在结果列表中权重最高</p><p><img src="/2020/03/06/头条搜索APP产品体验/ttindex2.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttsearch.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttsearch3.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttsearch2.jpg"> </p><h4 id="1-2-搜索分类"><a href="#1-2-搜索分类" class="headerlink" title="1.2 搜索分类"></a>1.2 搜索分类</h4><p><img src="/2020/03/06/头条搜索APP产品体验/ttfl.png"> </p><p>通过对比《头条搜索》《百度》。《百度》分类更多，更加精细。而《头条搜索》除“音乐”栏目接入的是“酷狗音乐”，更多是接入自家流量池的内容。以搜索将文章、视频等内容关联起来，不过在个人中心提及的“小说”在这里却没有单独的分栏。</p><p>也就是说，通过此搜索入口，可以将字节自家的大部分产品的内容全部聚合起来，形成综合类的信息平台。</p><h4 id="1-3-搜索结果"><a href="#1-3-搜索结果" class="headerlink" title="1.3 搜索结果"></a>1.3 搜索结果</h4><p>通过对比《头条搜索》和《百度》的搜索结果，可以发现二者的内容还是有很大的区别的，《百度》的搜索结果主要以自家平台(如百家号，贴吧等)+第三方信息，而《头条搜索》的搜索结果更偏向自家的生态内容，以头条号的内容为主。《百度》更贴近于全网搜索。</p><p>在用户体验上，《百度》上争议最大的广告问题，一直是用户吐槽的重灾区，而《头条搜索》似乎是想在用户体验上给自己提高分数，在搜索结果中没有看到广告的身影。不直到对于广告，字节在后期会怎么处理。</p><p>以下是搜索的测试案例：100-25、1美元、火车、减肥、英文的英文、感冒吃什么药，姚明和奥尼尔谁高;</p><p><img src="/2020/03/06/头条搜索APP产品体验/ttjs.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/tthl.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttenglish.jpg"> </p><p>通过测试结果发现《头条搜索》的搜索引擎可以对大量的特殊语义进行识别并给出相应答案，和《百度》并无差别，不过在搜索“姚明和奥尼尔谁高”这一问题时，《百度》直接给出了答案，《头条搜索》只显示了相关资讯文章。</p><p><img src="/2020/03/06/头条搜索APP产品体验/ttym2.jpg"><br><img src="/2020/03/06/头条搜索APP产品体验/ttym.jpg"> </p><h3 id="2-视频、小视频、小说"><a href="#2-视频、小视频、小说" class="headerlink" title="2. 视频、小视频、小说"></a>2. 视频、小视频、小说</h3><p>内容上《头条搜索》提供了长视频、短视频、小说、直播等丰富的内容。</p><p>《头条搜索》视频栏目接入的时《西瓜视频》，主要以时长1-5分钟的内容为主。小视频接入的是《抖音》《抖音火山版》，依靠这两大内容池，不但可以提供优势的视频内容素材，还可以满足不同用户的需求。不过在播放视频时，切换视频的手势操作为左右滑动，上下滑动则为弹出回复关闭回复。不知道为什么没有沿用自家应用的用户使用习惯，上下滑动切换视频，导致在体验过程中十分的不习惯，这一点不知道后期会不会有改动。</p><p>至此，《头条搜索》里已经包含图文、长视频、短视频、音频、直播等多种的内容形态</p><h2 id="产品总结"><a href="#产品总结" class="headerlink" title="产品总结"></a>产品总结</h2><p>整体体验下来，《头条搜索》更像是精简版的《今日头条》，分别在《今日头条》《头条搜索》中搜索关键字，所得结果是相同的。作为一款独立的App，并没有给我更多的惊喜，可能更多的是出于商业上的考量。</p>]]></content>
      
      
      <categories>
          
          <category> 产品经理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品经理 </tag>
            
            <tag> 产品体验 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《腾讯产品法》-需求分析法</title>
      <link href="/2020/03/01/%E3%80%8A%E8%85%BE%E8%AE%AF%E4%BA%A7%E5%93%81%E6%B3%95%E3%80%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2020/03/01/%E3%80%8A%E8%85%BE%E8%AE%AF%E4%BA%A7%E5%93%81%E6%B3%95%E3%80%8B-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="五种需求分析底层产品思维：本质思维、相对思维、抽象思维、系统思维、演化思维"><a href="#五种需求分析底层产品思维：本质思维、相对思维、抽象思维、系统思维、演化思维" class="headerlink" title="五种需求分析底层产品思维：本质思维、相对思维、抽象思维、系统思维、演化思维"></a>五种需求分析底层产品思维：本质思维、相对思维、抽象思维、系统思维、演化思维</h2><ul><li>本质思维：第一性原理<ul><li>概念：所有产品设计，说穿了都是在构建体系，而只有了解这个体系<code>本质</code>上是什么，才有可能以最高效的方式完成逆向构建。所以产品设计者最重要的思维能力就是洞察问题本质的能力。在物理学领域，这种思考方式被称作“第一性原理”。它的意思是：从头算起，只采用最基本的事实作为依据，然后再层层推导，得出结论。</li><li>如何实践：我们可以采用<code>连环追问法</code>不断地追问“为什么”的方式去实践，通过对问题的连环追问，我们能能发现表面问题背后的真正问题到底是什么；通过对人的连环追问，我们能弄清楚人们的真正需要的是什么。</li></ul></li><li>相对思维：日光与阴影<ul><li>概念：事物与事物之间的关系和时间带来的变化影响着我们如何看待事物。在完全相同的一片市场领域中，往往是你的对手和你选择的用户群共同决定你了位置，但同时，随着时间段额变化，关系必然发生变化，你的位置需要随之调整。这在产品战略中无疑是重要的。</li><li>如何实践：一个产品设计着首先要保持“不下定义”的觉悟，才能看到事物与事物之间的“关系”和“变化”，而不是只瞧见那些暂时玄关在事物身上的标签。创新、抄袭、刚需、伪需求、高效、冗余。简而言之，合格的产品设计者一定是思考者，而思考者不会是二元论者，万事万物都在“相对”中找寻一种平衡。</li></ul></li><li>抽象思维：大圣的火眼金睛<ul><li>概念：既能用“火眼金睛”看骨骼，也能切换到“肉眼”模式看体验。这种在“设计专家型”视角和“白痴级用户”之间自由转换的能力。</li><li>如何实践：<ul><li>具象与抽象：把性质相近的元素合并到一类，随着观察视角的升高，产品的骨骼就会逐步显露出来。因此，抽象的过程实际上是先分类、再提升视角的过程。好的产品设计，就是运用数量有限的基础能力，去实现高满意度的功能(当然是应用频率也很重要，这和用户对产品的自然需求相关)。而没有信心的表现，往往是只要和产品沾点边，就这个功能也做，那个功能也做，不知道哪个功能效果好，做了一大堆功能，最后却发现很多功能用户根本不会去用。了解本质永远比学会套路更重要，因为前者意味着创新诞生的可能。</li><li>考虑新元素而非新功能：不要考虑添加的功能是什么，而去考虑添加对的新能力(元素)是什么。分解与聚合，具象和抽象的思考非常有意思。高度抽象带来产品设计的高度简洁。利用这些不同的“能力元素”，一个产品可以架构出丰富多样的功能形态出来。就像千变万化的乐高玩具，其计出的模件并不太多是一个道理。多多使用抽象思维思考你的产品，想明白它用到的“能力元素”有哪些，在此基础上再慎重考虑要不要引入一些全新的“能力元素”。这些比起只考虑做些什么“新功能”，或许或更接近产品设计的本质。一个产品简介高效或冗余繁琐的关键差异，往往就在这里。</li></ul></li></ul></li><li><p>系统思维：镜中变色龙</p><ul><li>概念：在做产品时，我们需要时刻关注产品细微的反馈，根据反馈做出合理的反馈决策；“反馈”模型是自然界和现实世界中无处不在的抽象模型，如何让“现实”向着我们“理想”中的状态推进，在动态变化的现实中，我们需要修炼自己的系统思维，看懂反馈。</li><li>如何实践：分析用户数据、做需求调研、A/B测试，都是我们需要去了解反馈，做出相应调整变化</li></ul></li><li><p>演化思维：自下而上的设计</p><ul><li>概念：演化思维是一种位于产品思维积木堆顶层的思维，需求的本质亘古不变，需求的显示上需要随着实践推移不断迭代演化。</li></ul></li></ul><blockquote><p>产品DNA是用户对于产品综合特征的认值，包含功能和品牌却远不止于功能和品牌。它包括了产品的设计理念、设计规则、品牌形象，它通过产品设计者做出的不同选择来形成定义。产品鼓励什么，拒绝什么，如何架构，如何演进，都共同决定一个产品的DNA</p></blockquote><h2 id="需求分析通用法则：5W1H"><a href="#需求分析通用法则：5W1H" class="headerlink" title="需求分析通用法则：5W1H"></a>需求分析通用法则：<code>5W1H</code></h2><ul><li>Who：<ul><li>产品为谁设计？目标用户？</li><li>谁购买？谁使用？</li><li>数量有多少？</li></ul></li><li>Why：<ul><li>用户为什么选择我们的产品？</li><li>除了我们的产品外，他还有哪些选择？</li><li>产品被替代的可能性大嘛？</li></ul></li><li>When：<ul><li>用户什么时候使用我们的产品？</li><li>多久使用一次，会使用多久？<blockquote><p>前三个问题决定了一个产品的方向，他们可以协助我们判断“做还是不做”一个产品</p></blockquote></li></ul></li><li>Where：<ul><li>用户在哪里使用我们的产品</li></ul></li><li>What：<ul><li>产品具体形式是什么样？做成什么样？</li></ul></li><li>How：<br>  用户是怎么使用它的？<blockquote><p>后三个问题则更为具体，它们数据确定“要做”后再进一步思考的问题。</p></blockquote></li></ul><p>根据产品设计实践，按照优先级顺序，我们大致可以将需求问题划分为一下两大类：</p><ul><li>需求与策略阶段————产品需求四要素<ul><li>Who：广度=主题</li><li>Why：强度=解决方案</li><li>When：频次、可持续性=时间</li></ul></li><li>产品设计阶段————需求场景分析模型<ul><li>Where：场景</li><li>What：方案形态</li><li>How：操作路径</li></ul></li></ul><p>前三个问题在需求和策略阶段确定。他们对应着产品的四要素：<code>广度</code>、<code>强度</code>、<code>频次</code>、<code>可持续性</code>。后面三个问题具体到产品设计阶段再解决。理论上，一个产品需求分析在这四要素维度综合得分越高，用户就会越要这个产品。可当我们继续深入分析就会发现，广度、频次和可持续性其实是受强度影响的。也就是说，“用户为什么选择产品”才是最重要的问题，四要素中只要抓住强度，所有的问题都可以迎刃而解。</p>]]></content>
      
      
      <categories>
          
          <category> 产品经理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品经理 </tag>
            
            <tag> 需求分析法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>母牛生小牛</title>
      <link href="/2019/12/31/NumOfCow/"/>
      <url>/2019/12/31/NumOfCow/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。第一年农场只有一只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛3年成熟后又可以生小母牛。给定整数N，求出N年后牛的数量。</p><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>所有的牛都不会死，所以第N-1年的牛会毫无损失的活到第N年。同时所有成熟的牛都会生1头小牛，那么成熟的牛数量如何估计？就是第N-3年的所有牛，到第N年肯定是成熟的牛，期间出生的牛肯定没有成熟。所以C(n) = C(n-1)+C(n-3),初始项C(1)==1,C(2)==2，C(3)==3。这个和斐波那契数列数列十分相似，只不过C(n)依赖C(n-1)和C(n-3)的值</p><h3 id="方法一-O-2-N"><a href="#方法一-O-2-N" class="headerlink" title="方法一  O(2^N^)"></a>方法一  O(2^N^)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">c1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> c1(n - <span class="number">1</span>) + c1(n - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法-O-N"><a href="#方法-O-N" class="headerlink" title="方法  O(N)"></a>方法  O(N)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">c2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> || n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            tmp1 = res;</span><br><span class="line">            tmp2 = pre;</span><br><span class="line">            res = res + prepre;</span><br><span class="line">            pre = tmp1;</span><br><span class="line">            prepre = tmp2;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java枚举类</title>
      <link href="/2019/11/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
      <url>/2019/11/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>enum</code> 全称是 enumeration，是 JDK1.5 引入的新特性，位于<code>Java.lang</code> 包下。<br>在Java中 <code>enum</code> 是一个关键字,被 <code>enum</code> 修饰的类型就是枚举类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ColorEnum&#123;</span><br><span class="line">    BLACK,WHITE,GREEN;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">### 枚举的好处</span><br><span class="line">将枚举类型用作set或map的类型时，专用且高效。(引自枚举类的介绍)</span><br><span class="line">### 枚举的典型应用</span><br><span class="line">如 状态码、常量、颜色、类别等</span><br><span class="line">### 使用规范</span><br><span class="line">- 枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 </span><br><span class="line">正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKNOWN_REASON</span><br><span class="line">- 所有的枚举类型字段必须要有注释，说明每个数据项的用途</span><br><span class="line">&gt; 引自阿里巴巴开发手册</span><br><span class="line"></span><br><span class="line">## 枚举的本质</span><br><span class="line">### 枚举类的声明</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>下面我们新建一个枚举类`ColorEnum``<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ColorEnum&#123;</span><br><span class="line">    BLACK,WHITE,GREEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>执行<code>javac ColorEnum.java</code> 命令，生成<code>ColorEnum.class</code> 文件.</li><li>接着执行<code>javap ColorEnum.class</code> 命令，输入如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">advanced</span>.<span class="title">learnenum</span>.<span class="title">ColorEnum</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">com</span>.<span class="title">sun</span>.<span class="title">advanced</span>.<span class="title">learnenum</span>.<span class="title">ColorEnum</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.sun.advanced.learnenum.ColorEnum BLACK;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.sun.advanced.learnenum.ColorEnum WHITE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.sun.advanced.learnenum.ColorEnum GREEN;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sun.advanced.learnenum.ColorEnum[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.sun.advanced.learnenum.<span class="function">ColorEnum <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>从上面可以看出，枚举的本质是<code>java.lang.Enum</code>的子类。<br>尽管<code>enum</code>看起来很像一种新的数据类型，但实际上，<strong>enum是一种受限制的类，并且有自己的方法</strong>。<br>枚举类被修饰为<code>final</code>,所以不能被其他类所继承。<br>定义的枚举值被修饰为<code>static final</code>,本质上枚举值就是一种静态常量</p><p>枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。—阿里巴巴开发手册</p></blockquote><h2 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h2><ul><li><code>String name()</code>: 返回此枚举常量的名称</li><li><code>int ordinal()</code>: 此枚举常量的序号（它在枚举声明中的位置，其中初始常量的序数为零）。</li><li><code>String toString</code>: 返回枚举常量名</li><li><code>boolean equals(Object other)</code>: 判断是否为同一个对象</li><li><code>Class&lt;E&gt; getDeclaringClass()</code>: 返回实例所属的 enum 类型</li><li><code>static &lt;T extends Enum&lt;T&gt;&gt; T valueOf valueOf(Class&lt;T&gt; enumType String name)</code>: 返回指定名字、给定类的枚举常量</li><li>int compareTo(E other): 如果枚举常量出现在other之前，则返回用一个负值；如果this==other,则返回0；否则，返回正值。枚举常量的出现次数在enum中给出</li></ul><p>可以使用<code>==</code> 来比较enum实例</p><p><code>enum</code>的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMethodDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"******************Print all color**************"</span>);</span><br><span class="line">        <span class="keyword">for</span> (ColorEnum colorEnum : ColorEnum.values()) &#123;</span><br><span class="line">            System.out.println(colorEnum + <span class="string">" ordinal "</span> + colorEnum.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"******************Print method**************"</span>);</span><br><span class="line"></span><br><span class="line">        ColorEnum black = ColorEnum.BLACK;</span><br><span class="line">        System.out.println(<span class="string">"black.name(): "</span> + black.name());</span><br><span class="line">        System.out.println(<span class="string">"black.getDeclaringClass(): "</span> + black.getDeclaringClass());</span><br><span class="line">        System.out.println(<span class="string">"black.hashCode(): "</span> + black.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"black.compareTo(ColorEnum.BLACK): "</span> + black.compareTo(ColorEnum.BLACK));</span><br><span class="line">        System.out.println(<span class="string">"black.equals(ColorEnum.BLACK): "</span> + black.equals(ColorEnum.BLACK));</span><br><span class="line">        System.out.println(<span class="string">"black.equals(ColorEnum.WHITE): "</span> + black.equals(ColorEnum.WHITE));</span><br><span class="line">        System.out.format(<span class="string">"black == ColorEnum.WHITE"</span>, black == ColorEnum.WHITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">******************Print all color**************</span><br><span class="line">BLACK ordinal 0</span><br><span class="line">WHITE ordinal 1</span><br><span class="line">GREEN ordinal 2</span><br><span class="line">******************Print method**************</span><br><span class="line">black.name(): BLACK</span><br><span class="line">black.getDeclaringClass(): class com.sun.advanced.learnenum.ColorEnum</span><br><span class="line">black.hashCode(): 1956725890</span><br><span class="line">black.compareTo(ColorEnum.BLACK): 0</span><br><span class="line">black.equals(ColorEnum.BLACK): true</span><br><span class="line">black.equals(ColorEnum.WHITE): false</span><br><span class="line">black == ColorEnum.WHITE</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><h2 id="枚举的特性"><a href="#枚举的特性" class="headerlink" title="枚举的特性"></a>枚举的特性</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加</p><h3 id="枚举可以添加方法"><a href="#枚举可以添加方法" class="headerlink" title="枚举可以添加方法"></a>枚举可以添加方法</h3><p><strong>枚举值认为从0开始的有序数值</strong>。</p><h3 id="枚举可以添加普通方法、静态方法、抽象方法、构造方法"><a href="#枚举可以添加普通方法、静态方法、抽象方法、构造方法" class="headerlink" title="枚举可以添加普通方法、静态方法、抽象方法、构造方法"></a>枚举可以添加普通方法、静态方法、抽象方法、构造方法</h3><p>Java中不允许使用<code>=</code>为枚举常量赋值。而是添加方法来间接实现显示赋值。</p><h3 id="枚举可以实现接口"><a href="#枚举可以实现接口" class="headerlink" title="枚举可以实现接口"></a>枚举可以实现接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  ErrorCodeEnum implements INumberEnum &#123;</span><br><span class="line"></span><br><span class="line">    OK(<span class="number">0</span>,<span class="string">"成功"</span>),</span><br><span class="line"></span><br><span class="line">    ERROR_A(<span class="number">100</span>,<span class="string">"错误A"</span>),</span><br><span class="line"></span><br><span class="line">    ERROR_B(<span class="number">200</span>,<span class="string">"错误B"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    ErrorCodeEnum(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = number;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><h3 id="组织常量"><a href="#组织常量" class="headerlink" title="组织常量"></a>组织常量</h3><p>以前，在Java中定义常量都是<code>public static final T A;</code>这样的形式。有了枚举类，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法</p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>我们经常使用switch语句来写状态机。JDK1.7以后，switch已经支持<code>int、</code>char<code>、</code>string<code>、</code>enum`类型的参数。这几种类型的参数比较起来，使用枚举的switch更具有可读性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StateEnum &#123;</span><br><span class="line">    GREEN,</span><br><span class="line">    YYELLOW,</span><br><span class="line">    RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getTrafficInstruct(StateEnum.RED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTrafficInstruct</span><span class="params">(StateEnum singal)</span></span>&#123;</span><br><span class="line">        String instruct = <span class="string">"信号灯故障"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (singal)&#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                instruct=<span class="string">"红灯停"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                instruct=<span class="string">"黄灯请注意"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YYELLOW:</span><br><span class="line">                instruct=<span class="string">"绿灯行"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instruct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红灯停</span><br></pre></td></tr></table></figure></p><h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>枚举常常用于定义程序错误码。下面使一个简单示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpStatusEnum &#123;</span><br><span class="line"></span><br><span class="line">    OK(<span class="number">200</span>,<span class="string">"成功"</span>),</span><br><span class="line">    NOT_FOUND(<span class="number">404</span>,<span class="string">"资源未找到"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    HttpStatusEnum(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpStateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (HttpStatusEnum value : HttpStatusEnum.values()) &#123;</span><br><span class="line">            System.out.println(value.getCode() +<span class="string">" "</span>+ value.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组织枚举"><a href="#组织枚举" class="headerlink" title="组织枚举"></a>组织枚举</h3><p>可以将类型接近的枚举通过接口或类组织起来来，但是一般用接口的方式进行组织。<br>原因是：Java接口在编译时会自动为enum类型加上<code>public static</code>修饰符；Java类编译时会自动为<code>enum</code>类型加上static修饰符，就是说，在类组织<code>enum</code>,如果你不给他修饰为public，那么之恶能在本包中进行访问</p><p>在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。举例来说，假设你想用enum来表示不同类别的食物，同时还希望每个enum元素仍然保持Food类型，那么可以这样实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Appetizer implements Food&#123;</span><br><span class="line">        SALAD,SOUP,SPRING_ROLLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> MainCourse implements Food&#123;</span><br><span class="line">        LASAGNE,BURRITO,PAD_THAI,</span><br><span class="line">        LENTILS,HUMMOUS,VINDALOO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Dessert implements Food&#123;</span><br><span class="line">        TIRAMISU,GELATO,FRUIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food&#123;</span><br><span class="line">        BLACK_COFFEE,DECAF_COFFEE,ESPRESSO,</span><br><span class="line">        LATTE,CAPPUCCINO,TEA,HERB_TEA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些枚举都实现了Food接口，所以可以利用Food对具体实例进行实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.advanced.learnenum.Food.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeOfFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = Appetizer.SALAD;</span><br><span class="line">        food = MainCourse.LASAGNE;</span><br><span class="line">        food = Dessert.GELATO;</span><br><span class="line">        food = Coffee.BLACK_COFFEE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举工具类"><a href="#枚举工具类" class="headerlink" title="枚举工具类"></a>枚举工具类</h2><p>Java 中提供了两个方便操作enum的工具类<code>EnumSet</code>，<code>EnumMap</code></p><h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p><code>Set</code>是一种集合，只能向其中添加不重复的对象。当然enum也要求成员都是唯一的，所以enum看起来也具有集合的行为。<code>EnumSet</code>是枚举类型的高性能<code>Set</code>实现。它要求放入它的枚举常量必须属于同一枚举类型</p><p>主要接口：</p><ul><li>noneOf：创建一个具有指定元素类型的空EnumSet</li><li>allOf：创建一个指定元素类型并包含所有枚举值的EnumSet</li><li>range: 创建一个包括枚举值中指定范围元素的EnumSet</li><li>complenmentsOf：初始化集合包括指定集合的补集</li><li>of：创建一个包括参数中所有元素的EnumSet</li><li>copyOf：创建一个包含参数容器的所有元素的EnumSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EnumSet&lt;HttpStatusEnum&gt; httpStatusEnums = EnumSet.allOf(HttpStatusEnum.class);</span><br><span class="line">        <span class="keyword">for</span> (HttpStatusEnum value : httpStatusEnums) &#123;</span><br><span class="line">            System.out.println(value.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p><code>EnumMap</code>是一种特殊的Map，它要求其中的key必须来自一个<code>enum</code>。由于enum本身的限制，所以EnumMap在内部可由数组实现。因此EnumMap的速度很快，我们可以放心的使用enum实例在EnumMap中进行查找操作。不过我们只能将enum的实例作为key来调用put()方法，其他操作与使用一般的Map差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EnumMap enumMap = <span class="keyword">new</span> EnumMap(StateEnum.class);</span><br><span class="line">        enumMap.put(StateEnum.RED,<span class="string">"红灯"</span>);</span><br><span class="line">        enumMap.put(StateEnum.GREEN,<span class="string">"绿灯"</span>);</span><br><span class="line">        enumMap.put(StateEnum.YYELLOW,<span class="string">"黄灯"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : enumMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Java编程思想</li><li><a href="https://juejin.im/post/5c90efacf265da60ce379e17#heading-16" target="_blank" rel="noopener">深入理解Java枚举类</a></li><li>阿里巴巴开发手册</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/2019/10/25/IDEAHotKey/"/>
      <url>/2019/10/25/IDEAHotKey/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>Ctrl+O:</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Ctrl+T：pull操作<br>Ctr+k：commit操作<br>Ctrl+Shift+K：push操作</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> IDEA </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson 常用API</title>
      <link href="/2019/10/25/fastjson/"/>
      <url>/2019/10/25/fastjson/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是fastjson"><a href="#什么是fastjson" class="headerlink" title="什么是fastjson"></a>什么是fastjson</h2><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串发序列化到Java Bean。</p><h2 id="fastjson优点"><a href="#fastjson优点" class="headerlink" title="fastjson优点"></a>fastjson优点</h2><h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p>fastjson相对其他的JSON库的特点是快，从2011年fastjson1.1x发布版本之后，其性能从未被其他Java实现的JSON库超越。</p><h3 id="使用广泛"><a href="#使用广泛" class="headerlink" title="使用广泛"></a>使用广泛</h3><p>fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开运中国评选为最受欢迎的国产开源软件之一。</p><h3 id="测试完备"><a href="#测试完备" class="headerlink" title="测试完备"></a>测试完备</h3><p>fastjson有很多的testcase，在1.2.11版本中，testcase超过3321个。每次发布都会进行回归测试，保证质量稳定。</p><h3 id="使用简单"><a href="#使用简单" class="headerlink" title="使用简单"></a>使用简单</h3><p>fastjson的API十分简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = JSON.toJSONString(obj); <span class="comment">//序列化</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>，VO.classs);  <span class="comment">//反序列话</span></span><br></pre></td></tr></table></figure></p><h3 id="功能完备"><a href="#功能完备" class="headerlink" title="功能完备"></a>功能完备</h3><p>支持泛型，支持流处理超大文本，支持枚举，支持序列化和反序列化扩展。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>maven中央仓库：<a href="http://central.maven.org/maven2/com/alibaba/fastjson/" target="_blank" rel="noopener">http://central.maven.org/maven2/com/alibaba/fastjson/</a></li><li>直接配置依赖<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt; x.x.x&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>JSON这个类是fastjson API的入口，主要功能都通过这个类提供</p><h3 id="序列化API"><a href="#序列化API" class="headerlink" title="序列化API"></a>序列化API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java对象序列化为JSON字符串，支持各种各种Java基本类型和JavaBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJSONString</span><span class="params">(Object object, SerializerFeature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Java对象序列化为JSON字符串，返回JSON字符串的utf-8 bytes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toJSONBytes(Object object, SerializerFeature... features);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Java对象序列化为JSON字符串，写入到Writer中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeJSONString</span><span class="params">(Writer writer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object object, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       SerializerFeature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Java对象序列化为JSON字符串，按UTF-8编码写入到OutputStream中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writeJSONString</span><span class="params">(OutputStream os, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                            Object object, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                            SerializerFeature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON字符串反序列化API"><a href="#JSON字符串反序列化API" class="headerlink" title="JSON字符串反序列化API"></a>JSON字符串反序列化API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(String jsonStr, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Class&lt;T&gt; clazz, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Feature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(<span class="keyword">byte</span>[] jsonBytes,  // UTF<span class="number">-8</span>格式的JSON字符串</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Class&lt;T&gt; clazz, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Feature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将JSON字符串反序列化为泛型类型的JavaBean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(String text, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    TypeReference&lt;T&gt; type, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    Feature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将JSON字符串反序列为JSONObject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><h4 id="parse-Tree"><a href="#parse-Tree" class="headerlink" title="parse Tree"></a>parse Tree</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.*;</span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = JSON.parseObject(jsonStr);</span><br></pre></td></tr></table></figure><h4 id="parse-POJO"><a href="#parse-POJO" class="headerlink" title="parse POJO"></a>parse POJO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Model model = JSON.parseObject(jsonStr, Model.class);</span><br></pre></td></tr></table></figure><h4 id="parse-POJO-Generic"><a href="#parse-POJO-Generic" class="headerlink" title="parse POJO Generic"></a>parse POJO Generic</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mport com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Type type = <span class="keyword">new</span> TypeReference&lt;List&lt;Model&gt;&gt;() &#123;&#125;.getType(); </span><br><span class="line">List&lt;Model&gt; list = JSON.parseObject(jsonStr, type);</span><br></pre></td></tr></table></figure><h4 id="convert-POJO-to-string"><a href="#convert-POJO-to-string" class="headerlink" title="convert POJO to string"></a>convert POJO to string</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Model model = ...; </span><br><span class="line">String jsonStr = JSON.toJSONString(model);</span><br></pre></td></tr></table></figure><h4 id="convert-POJO-to-json-bytes"><a href="#convert-POJO-to-json-bytes" class="headerlink" title="convert POJO to json bytes"></a>convert POJO to json bytes</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Model model = ...; </span><br><span class="line"><span class="keyword">byte</span>[] jsonBytes = JSON.toJSONBytes(model);</span><br></pre></td></tr></table></figure><h4 id="write-POJO-as-json-string-to-OutputStream"><a href="#write-POJO-as-json-string-to-OutputStream" class="headerlink" title="write POJO as json string to OutputStream"></a>write POJO as json string to OutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Model model = ...; </span><br><span class="line">OutputStream os;</span><br><span class="line">JSON.writeJSONString(os, model);</span><br></pre></td></tr></table></figure><h4 id="write-POJO-as-json-string-to-Writer"><a href="#write-POJO-as-json-string-to-Writer" class="headerlink" title="write POJO as json string to Writer"></a>write POJO as json string to Writer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">Model model = ...; </span><br><span class="line">Writer writer = ...;</span><br><span class="line">JSON.writeJSONString(writer, model);</span><br></pre></td></tr></table></figure><h3 id="JSONField"><a href="#JSONField" class="headerlink" title="JSONField"></a>JSONField</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p>注意：若属性是私有的，必须有set方法。否则无法序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JSONField &#123;</span><br><span class="line">     <span class="comment">//配置序列化和反序列化的顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定字段的名称</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//指定字段的格式，对日期格式有用</span></span><br><span class="line">    <span class="function">String <span class="title">format</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//是否序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">serialize</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//是否反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deserialize</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">    SerializerFeature[] serialzeFeatures() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Feature[] parseFeatures() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//当你有一个字段是字符串类类型，里面是json格式数据，你希望直接输入，而不是经过转义之后再输出</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">jsonDirect</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//指定属性的序列化类</span></span><br><span class="line">    Class&lt;?&gt; serializeUsing() <span class="keyword">default</span> Void.class;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; deserializeUsing() <span class="keyword">default</span> Void.class;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//支持反序列化时使用多个不同的字段名称</span></span><br><span class="line">    String[] alternateNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unwrapped</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>JSONField可以配置在<strong>字段</strong>或者<strong>setter/getter</strong>方法上。例如:</p><h5 id="配置在字段上"><a href="#配置在字段上" class="headerlink" title="配置在字段上"></a>配置在字段上</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@JSONField</span>(name=<span class="string">"ID"</span>)</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;<span class="keyword">this</span>.id = id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置在setter-getter上"><a href="#配置在setter-getter上" class="headerlink" title="配置在setter/getter上"></a>配置在setter/getter上</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@JSONField</span>(name=<span class="string">"ID"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">      <span class="meta">@JSONField</span>(name=<span class="string">"ID"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;<span class="keyword">this</span>.id = id;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用format配置日期格式化"><a href="#使用format配置日期格式化" class="headerlink" title="使用format配置日期格式化"></a>使用format配置日期格式化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">     <span class="comment">//配置date序列化和反序列化使用yyyyMMdd日期格式</span></span><br><span class="line">     <span class="meta">@JSONField</span>(format=<span class="string">"yyyyMMdd"</span>)</span><br><span class="line">     <span class="keyword">public</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用serialize-deserialize指定字段不序列化"><a href="#使用serialize-deserialize指定字段不序列化" class="headerlink" title="使用serialize/deserialize指定字段不序列化"></a>使用serialize/deserialize指定字段不序列化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="meta">@JSONField</span>(serialize=<span class="keyword">false</span>)</span><br><span class="line">     <span class="keyword">public</span> Date date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="meta">@JSONField</span>(deserialize=<span class="keyword">false</span>)</span><br><span class="line">     <span class="keyword">public</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用ordinal指定字段的顺序"><a href="#使用ordinal指定字段的顺序" class="headerlink" title="使用ordinal指定字段的顺序"></a>使用ordinal指定字段的顺序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JSONField</span>(ordinal = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f0;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField</span>(ordinal = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField</span>(ordinal = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSONPath"><a href="#JSONPath" class="headerlink" title="JSONPath"></a>JSONPath</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>可以在java框架中当作对象查询语言使用</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONPath</span> </span>&#123;          </span><br><span class="line">     <span class="comment">//  求值，静态方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">eval</span><span class="params">(Object rootObject, String path)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 计算Size，Map非空元素个数，对象非空元素个数，Collection的Size，数组的长度。其他无法求值返回-1</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Object rootObject, String path)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 是否包含，path中是否存在对象</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object rootObject, String path)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 是否包含，path中是否存在指定值，如果是集合或者数组，在集合中查找value是否存在</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object rootObject, String path, Object value)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 修改制定路径的值，如果修改成功，返回true，否则返回false</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(Object rootObject, String path, Object value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在数组或者集合中添加元素</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">array_add</span><span class="params">(Object rootObject, String path, Object... values)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持语法"><a href="#支持语法" class="headerlink" title="支持语法"></a>支持语法</h4><div class="table-container"><table><thead><tr><th>JSONPATH</th><th>描述 </th></tr></thead><tbody><tr><td>$</td><td>根对象，例如$.name</td></tr><tr><td>[num]</td><td>数组访问，其中num是数字，可以是符数。例如$[0].leader.departments[-1].name</td></tr><tr><td>[num0,num1,…]</td><td>数组多个元素访问，其中num是数字，可以是负数，返回数组中的多个元素。例如$[0,3,-1,4]</td></tr><tr><td>[start:end]</td><td>数组范围访问，其中start和end是开始下标和结束下标，可以是负数，返回数组中的多个元素。例如$[0:5]</td></tr><tr><td>[?(key)]</td><td>对象属性非空过滤，例如$.departs[?(name)]</td></tr><tr><td>[key &gt; 123]</td><td>数值类型对象属性比较过滤，例如$.departs[id&gt;=123],比较操作符支持=，！=，&gt;,&gt;=,&lt;,&lt;=</td></tr><tr><td>[key like ‘aa%’]</td><td>字符串类型like过滤，例如departs[name like ‘aa(.)*’],通配符只支持%；支持not like</td></tr><tr><td>[key rlike ‘regexpr’]</td><td>字符串类型正则匹配过滤，例如departs[name like ‘aa(.)*’]，正则语法为jdk的正则语法，支持not rlike</td></tr><tr><td>[key between 234 and 456]</td><td>BETWEEN过滤, 支持数值类型，支持not between 例如: $.departs[id between 101 and 201];$.departs[id not between 101 and 201]</td></tr><tr><td>length() 或者 size()</td><td>数组长度。例如$.values.size() 支持类型java.util.Map和java.util.Collection和数组</td></tr><tr><td>.</td><td>属性访问，例如$.name</td></tr><tr><td>..</td><td>deepScan属性访问，例如$..name</td></tr><tr><td>*</td><td>对象的所有属性，例如$.leader.*</td></tr><tr><td>[‘key’]</td><td>属性访问。例如$[‘name’]</td></tr><tr><td>[‘key0’,’key1’]</td><td>多个属性访问。例如$[‘id’,’name’]</td></tr></tbody></table></div><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p> toString 将java对象序列化为JSON字符串，fastjson提供了一个最简单的入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toJSONString</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="writeJSONString"><a href="#writeJSONString" class="headerlink" title="writeJSONString"></a>writeJSONString</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Fastjson在1.2.11版中，JSON类新增对OutputStream/Writer直接支持<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writeJSONString</span><span class="params">(OutputStream os, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Object object, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                             SerializerFeature... features)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writeJSONString</span><span class="params">(OutputStream os, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Charset charset, //  </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Object object, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                             SerializerFeature... features)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writeJSONString</span><span class="params">(Writer os, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                             Object object, // </span></span></span><br><span class="line"><span class="function"><span class="params">                                             SerializerFeature... features)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pareObject"><a href="#pareObject" class="headerlink" title="pareObject"></a>pareObject</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>在1.2.11版本中，fastjson新增加了对InputStream的支持<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(InputStream is, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Type type, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Feature... features)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(InputStream is, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Charset charset, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Type type, //</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Feature... features)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Api-Stream"><a href="#Api-Stream" class="headerlink" title="Api Stream"></a>Api Stream</h3><p>Fastjson 当需要处理超大JSON文本时，需要Stream API</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="超大数组序列化"><a href="#超大数组序列化" class="headerlink" title="超大数组序列化"></a>超大数组序列化</h5><p>如果你的JSON格式是一个巨大的JSON数组，有很多元素，则先调用startArray，然后挨个写入对象，然后调用endArray<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONWriter writer = <span class="keyword">new</span> JSONWriter(<span class="keyword">new</span> FileWriter(<span class="string">"文件位置"</span>));</span><br><span class="line">writer.startArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">1000</span>;++i)&#123;</span><br><span class="line">     writer.writeValue(<span class="keyword">new</span> VO());</span><br><span class="line">&#125;</span><br><span class="line">writer.endArray();</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><h5 id="超大JSON对象序列化"><a href="#超大JSON对象序列化" class="headerlink" title="超大JSON对象序列化"></a>超大JSON对象序列化</h5><p>如果你的JSON格式是一个巨大的JSONObject，有很多Key/Value对，则先调用startObject，然后挨个写入Key和Value，然后调用endObject。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JSONWriter writer = <span class="keyword">new</span> JSONWriter(<span class="keyword">new</span> FileWriter(<span class="string">"文件位置"</span>));</span><br><span class="line">writer.startObject();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">1000</span>;++i)&#123;</span><br><span class="line">     writer.writeKey(<span class="string">"x"</span>+i);</span><br><span class="line">     writer.writeVaue(<span class="keyword">new</span> VO());</span><br><span class="line">&#125;</span><br><span class="line">wirter.endObject();</span><br><span class="line">wirter.close();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> fastjson </tag>
            
            <tag> alibaba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2019/10/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/10/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步通常来形容一次方法调用。同步方法一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于异步目前比较经典以及常用的实现方式就是消息队列：在不使用消息队列服务器的时候，用户的请求请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器速度快于数据库(消息队列比数据库有更好的伸缩性)，因此响应速度得到大幅改善</span><br></pre></td></tr></table></figure></p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>它们都可以表示两个或多个任务一起执行，但是偏重点有些不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上“同时执行”</p><p>多线程再单核CPU中是顺序执行，也就是交替运行(并发)。多核CPU，因为每个CPU有自己的运算器，所以再多个CPU中可以同时运行(并行)</p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>高并发是互联网分布式系统架构设计中必须考量的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求</p><p>高并发相关常用的一些指标有响应时间(Response Time)、吞吐量(Throughput)、每秒查询率QPS(Query Per Second)、并发用户数等</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Java中的线程生命周期由JVM控制。具体实现使用<code>Thread.State</code>定义了线程物种状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        NEW,</span><br><span class="line">        RUNNABLE,</span><br><span class="line">        BLOCKED,</span><br><span class="line">        WAITING,</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要想实现多线程，必须在主线程中创建新的线程对象，Java语言使用Thread类及其子类的对象表示线程，在它的一个完整生命周期中通常要经历以下几种状态：</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li><strong>NEW</strong><br>创建后尚未启动的线程处于此状态。<br>新建了一个线程对象，但还没有调用<code>start()</code>方法</li><li><strong>RUNNABLE</strong><br>可运行线程的线程状态。处于可运行状态的线程正在Java虚拟机中执行，但可能正在等待来在操作系统的其他资源，例如处理器。(可能正在运行，也可能正在等待CPU时间片，包含了操作系统状态中的<code>Running</code>，<code>Ready</code>)<br>调用<code>start()</code>方法后，线程处于此状态</li><li><strong>BLOCKED</strong><br>线程的线程状态被阻塞，等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定输入同步块/方法或调用后重新进入同步块/方法</li><li><strong>WAITING</strong><br>等待线程的线程状态。等待其他线程显示的唤醒，否则不会分配CPU时间片。</li></ul><div class="table-container"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置Timeout参数的<code>Object.wait()</code>方法</td><td><code>Object.notify()/Object.notifyAll()</code></td></tr><tr><td>没有设置Timeout参数<code>Thread.join()</code>方法</td><td>被调用的线程执行完毕</td></tr><tr><td><code>LockSupport.park()</code>方法</td><td><code>LockSupport.unpark(Thread)</code></td></tr></tbody></table></div><ul><li><strong>TIMED_WAITING</strong><br>具有指定等待时间的等待线程的线程状态。无限期等待其他线程显式的唤醒，在一定时间之后会被系统自动唤醒。</li></ul><div class="table-container"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td><code>Thread.sleep()</code>方法</td><td>时间结束</td></tr><tr><td>设置了Timeout参数<code>Object.join()</code>方法</td><td>时间结束/<code>Object.notify()/Object.notifyAll()</code></td></tr><tr><td>设置了Timeout参数<code>Thread.join()</code>方法</td><td>时间结束/被调用的线程执行完毕</td></tr><tr><td><code>LockSupport.parkNanos()</code>方法</td><td><code>LockSupport.unpark(Thread)</code></td></tr><tr><td><code>LockSupport.parkUntil()</code>方法</td><td><code>LockSupport.unpark(Thread)</code></td></tr></tbody></table></div><ul><li><strong>TERMINATED</strong><br>终止线程的线程状态。线程已经完成执行，或者产生了异常</li></ul><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img src="/2019/10/10/Java多线程/threadlife.png" alt="threadlife"></p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个Java线程都有一个优先级。，这样有助于操作系统确定线程的调度顺序。</p><p>Java线程的优先级是一个整数，其取值范围是1(Thread.MIN_PRIORITY) — 10(Thread.MAX_PRIORITY)。默认情况下，每一个线程都会分配一个优先级(NORM_PRIORITY)=5</p><p>可以使用<code>setPriority()</code>方法提高或降低任何一个线程的优先级</p><h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h2><p>Java提供了3种创建线程的方法：</p><ul><li>实现Runnable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于执行线程的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建一个Runnalbe接口的类之后，你可以在类中实例化一个线程对象<br>Thread的构造方法中，下面是我们经常使用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line"></span><br><span class="line">Thread(Runnable target, String name)</span><br></pre></td></tr></table></figure></p><p>这里，target是一个实现Runnable接口类的实例，并且name指定新线程的名字</p><p>新线程创建之后，调用它的<code>start()</code>方法才会运行</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myThread is running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        myThread m1 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(m1).start</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread is running</span><br></pre></td></tr></table></figure></p><p>如果没有扩展<code>Thread</code>类，类对象不会被视为一个线程对象。所以需要明确的创建<code>Thread</code>类对象。传递实现<code>Runnable</code>类的实例，以便类的<code>run()</code>方法可以执行。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ol><li>创建一个继承与Thread类的子类</li><li>重写Thread类的run()方法—&gt; 将此线程的声明在run()中</li><li>创建Thread类的子类对象</li><li>通过此对象调用start()：①启动当前线程，②调用当前线程的run()</li></ol><p>当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法</p><p>该方法虽然被视为一种多线程的实现方式，但是本质上也是实现了Runnable接口的一个实例</p><p>举例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest01</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">": "</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest01 t1 = <span class="keyword">new</span> ThreadTest01();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable-VS-继承Thread"><a href="#实现Runnable-VS-继承Thread" class="headerlink" title="实现Runnable VS 继承Thread"></a>实现Runnable VS 继承Thread</h3><ol><li>有限选择实现Runnable接口的方式<ul><li>Java不支持多继承，因此继承了Thread类就无法继承其他类，但是可以实现多个接口</li><li>类可能只要求可执行即可，继承整个Thread类开销过大</li><li>实现的方式更适合处理线程共享数据的情况</li></ul></li><li><p>两者之间的联系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两种方式的相同点：<br>两种方式都需要重写<code>run()</code>方法，将线程要执行的逻辑声明在<code>run()</code>中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——应用层</title>
      <link href="/2019/08/30/net6/"/>
      <url>/2019/08/30/net6/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>DNS是一个分布式数据库，提供了域名和IP地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留他自己的那部分数据。</p><p>域名具有层次结构，从上到下以此为：根域名、顶级域名、二级域名<br><img src="/2019/08/30/net6/yuming.jpg" alt="yuming"></p><p>DNS 可以使用UDP或者TCP进行传输，使用的端口都为53。大多数情况下DNS使用UDP进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在这两种情况下使用TCP进行传输：</p><ul><li>如果返回的响应超过512字节(UDP最大支持512字节的数据)</li><li>区域传送(区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据)</li></ul><h3 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><p>FTP使用TCP进行连接，它需要两个连接来传送一个文件：</p><ul><li>控制连接: 服务器打开端口号21等待客户端的连接，刻划断主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据</li></ul><p>根据数据连接是否是服务器端主动建立，FTP有主动和被动两种模式：</p><ul><li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为20，客户端的端口号随机，但是必须大于1024，因为0-1023是熟知端口号</li><li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务端的端口号随机</li></ul><p>主动模式要求客户端开放端口号给服务端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务端的安全性减弱，因为开放了过多的端口号。</p><h3 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h3><p>DHCP(Dynamic Host Configuration Protocol)提供了即插即用的联网方式，用户不再需要受到配置IP地址等信息。</p><p>DHCP 配置的内容不仅是IP地址，还包括子网掩码、网关IP地址。</p><p>DHCP工作过程如下：</p><ol><li>客户端发送Discover报文，该报文的目的地址为255.255.255.255:67,源地址为0.0.0.0：68，被放入UDP中，该报文被广播到同一个子网的所有主机上。如果客户端和DHCP服务器不在用一个子网，就需要使用中继续代理。</li><li>DHCP 服务器受到Discover报文之后，发送Offer报文给客户端，改变报文包含了客户端所需要的信息。因为客户端可能受到多个DHCP服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个DHCP服务器提供的信息，那么就发送Request报文给该DHCP服务器。</li><li>DHCP 服务器发送Ack报文，表示客户端此时可以使用提供给他的信息。<br><img src="/2019/08/30/net6/dhcp.jpg" alt="dhcp"></li></ol><h3 id="远程登录协议"><a href="#远程登录协议" class="headerlink" title="远程登录协议"></a>远程登录协议</h3><p>TELNET 用于登录都远程主机上，并且远程主机上的输出也会返回</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统的换行符定义</p><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议<br>邮件协议包含发送协议和读取协议，发送协议常用SMTP，读取协议常用POP3和IMAP。</p><p><img src="/2019/08/30/net6/email.png" alt="email"></p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP 只能发送ASCII码，而互联网邮件扩充MIME可以发送二进制文件。MIME并没有改动或者取代SMTP，而是增加邮件主题的结构，定义了非ASCII码的编码规则。<br><img src="/2019/08/30/net6/stmp.png" alt="smtp"></p><h3 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本POP3可以不删除邮件</p><h3 id="Web页面请求过程"><a href="#Web页面请求过程" class="headerlink" title="Web页面请求过程"></a>Web页面请求过程</h3><h4 id="1-DHCP-配置主机"><a href="#1-DHCP-配置主机" class="headerlink" title="1. DHCP 配置主机"></a>1. DHCP 配置主机</h4><ul><li>假设主机最开始没有IP地址以及其他信息，那么就需要使用DHCP来获取。</li><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。</li><li>该报文端则被放入一个具有广播IP目的地址(255.255.255.255)和源IP地址的UDP报文段中。</li><li>该数据报被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，并将广播到与交换机连接的所有设备。</li><li>连接在交换机的DHCP服务器受到广播帧之后，不断地向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文含有以下信息：IP地址、DNS服务器的IP地址、默认网关的IP地址和子网掩码。该报文段被放入UDP报文段中，UDP报文段有被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直到向哪个接口发送该帧。</li><li>主机受到该帧后，不断分解得到DHCP报文。之后就配置它的IP地址、子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。</li><li>主机收到该帧后，不断分解得到DHCP报文。之后就配置它的IP地址、子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。</li></ul><h4 id="2-ARR解析MAC地址"><a href="#2-ARR解析MAC地址" class="headerlink" title="2. ARR解析MAC地址"></a>2. ARR解析MAC地址</h4><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站的域名对应的IP地址。</li><li>主机生成一个DNS查询报文，该报文具有53号端口，因为DNS服务器的端口号是53</li><li>该DNS查询报文被放入目的地址为DNS服务器IP地址的IP数据报中</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li>DHCP过程只知道网关路由器的IP地址，为了获取网关路由器的MAC地址，需要使用ARR协议</li><li>主机生成一个包含目的地址为网关路由器IP地址ARP查询报文，将该ARP查询报文放入一个具有广播目的地址(FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到ARP报文，发现其中的IP地址与其接口的IP地址匹配，因此就发送一个ARP回答报文，包含了它的MAC地址，发回给主机。</li></ul><h4 id="3-DNS解析域名"><a href="#3-DNS解析域名" class="headerlink" title="3. DNS解析域名"></a>3. DNS解析域名</h4><ul><li>知道了网关路由器的MAC地址后，就可以继续DNS的解析过程了</li><li>网关路由器接收到包含DNS查询报文的以太网帧后，抽取出IP数据包，并根据转发表决定该IP数据报应该转发的路由器</li><li>因为路由器具有内部网关协议(RIP、OSPF)和外部网关协议(BGP)这两种路由选择协议，因此路由表中已经配置了网关路由器到达DNS服务器的路由表项。</li><li>到达DNS服务器之后，DNS服务器抽取出DNS查询报文，并在DNS数据库中查找待解析的域名</li><li>找到DNS记录之后，发送DNS回答报文，将该回答报文放入UDP报文段中，然后放入IP数据报中，通过路由器反向发送回网关路由器，并经过以太网交换机到达主机</li></ul><h4 id="4-HTTP请求页面"><a href="#4-HTTP请求页面" class="headerlink" title="4. HTTP请求页面"></a>4. HTTP请求页面</h4><ul><li>有了HTTP请求的IP地址后，主机就能够生成TCP套接字将用于向Web服务器发送了HTTP GET报文</li><li>在生成TCP套接字之前，必须先与HTTP服务器进行三次握手来建立连接。生成一个具有目的端口80的TPC SYN 报文段，并向HTTP 服务器发送该报文段。</li><li>HTTP服务器收到该报文段之后， 生成TCP SYN ACK 报文段，发送回主机</li><li>HTTP连接建立后，浏览器生成HTTP GET 报文，并交付个HTTP服务器</li><li>HTTP服务器从TCP套接字读取HTTP GET 报文，生成一个HTTP响应报文，将Web页面内容放入报文主题中，发回给主机</li><li>浏览器手动HTTP响应报文后，抽取出Web页面内容，之后进行渲染，显示Web页面</li></ul><p>参考：<a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——传输层</title>
      <link href="/2019/08/30/net5/"/>
      <url>/2019/08/30/net5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是两个传输层实体之间有一条端到端的逻辑通信信道</p><h2 id="UDP和TCP的特点"><a href="#UDP和TCP的特点" class="headerlink" title="UDP和TCP的特点"></a>UDP和TCP的特点</h2><p>用户数据报协议UDP(User Datagram Protocol)</p><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的连接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul><p>传输控制协议TCP(Transmission Control Protoclo)</p><ul><li>面向连接</li><li>提供可靠交付，有流量控制，拥塞控制，提供全双工通信</li><li>面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不同的数据块)，</li><li>每一条TCP连接只能是点对点的(一对一)</li></ul><h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="/2019/08/30/net5/udp.jpg" alt="udp"><br>首部字段只有8个字节，包括源端口、目的端口、长度、检验和。12字节的伪首部是为了计算校验和临时添加的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="/2019/08/30/net5/tcp.png" alt="tcp"></p><ul><li>序号：用于对字节流进行编号，例如序号301，表示第一个字节的编号为301，如果携带的数据长度为100字节，那么下一个报文段的序号应为401</li><li>确认号：期望收到的下一个报文段的序号。例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200个字节，因此B希望下一个报文段的序号为701，B发送给A的确认号九尾701</li><li>数据偏移：指的是数据部分举例报文段起始处的偏移量，实际上值得是首部的长度</li><li>确认ACK：当ACK=1时确认号字段有效，否则无效。TCP规定，在连接建立后所以有传送的报文段必须把ACK置1</li><li>同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中SYN=1，ACK=1</li><li>中止FIN：用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放连接</li><li>窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h3><ul><li>URG：紧急指针标志</li><li>ACK：确认序号标志</li><li>PSH：push标志</li><li>RST: 充值连接标志</li><li>SYN：同步序列号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接</li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p><img src="/2019/08/30/net5/woshou.png" alt="woshou"><br>假设A为客户端，B为服务端</p><ul><li>首先B处于LISTEN(监听)状态，等待客户端的连接请求</li><li>A向B发送请求连接报文，SYN=1，ACK=0，选择一个初始的序号x</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN=1，<br>ACK=1，确认号为x+1,同时也选择一个初始的序号y</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为y+1,序号为x+1</li><li>B收到A的确认后，连接建立</li></ul><h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><p>第三次握手时为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会很长时一端时间才能收到服务端发挥的连接请求。客户都安等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端就会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h4 id="首次握手的隐患—-SYN超时"><a href="#首次握手的隐患—-SYN超时" class="headerlink" title="首次握手的隐患—-SYN超时"></a>首次握手的隐患—-SYN超时</h4><p>问题起因分析</p><ul><li>Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认</li><li>Server不断重试至超时，Linux默认等待63才断开连接</li></ul><p>针对SYN Flood的保护措施</p><ul><li>SYN队列满后，通过tcp_syncookies参数回发SYN Cookie</li><li>若为正常连接则Client会回发SYN Cookie，直接建立连接</li></ul><p>建立连接后，Client出现出现故障怎么办<br>保活机制</p><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍未收到响应则终端连接</li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p><img src="/2019/08/30/net5/four.png" alt="four"></p><ul><li>A发送连接释放报文FIN=1</li><li>B收到之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据</li><li>当B不再需要连接时，发送连接释放报文FIN=1</li><li>当A收到后发出确认，进入TIME-WAIT状态，等待2MSL(最大报文存活时间后释放连接)</li><li>B收到A的确认后释放连接</li></ul><blockquote><p>百度百科<br>tcp四次挥手，由于TCP连接时全双工的，因此每个方向都必须单独进行关闭<br>这个原则是当一方完成它的数发送任务就能发送一个FIN来中止这个方向的连接。收到一个FIN只以为者这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端A发送一个FIN，用来关闭客户端A到服务器B的数据传送</li><li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号。</li><li>服务器B关闭与客户端A的李连杰，发送一个FIN给客户端A</li><li>客户端A发回ACK报文确认，并将确认号设置为收到序号加1</li></ol></blockquote><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了FIN连接释放报文后，服务器收到了这个报文，就进入CLOSE-WAIT状态。这个状态是为了让服务器发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</p><h3 id="为什么有TIME-WAIT状态"><a href="#为什么有TIME-WAIT状态" class="headerlink" title="为什么有TIME_WAIT状态"></a>为什么有TIME_WAIT状态</h3><p>客户端收到服务端的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要要等待一个时间计时器设置的时间2MLS。这么做有两个原因</p><ul><li>确保最后一个确认报文能够达到。如果B没收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生 </li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>TCP使用了超时重传实现可靠传输：如果一个已经发送的报文段在超时时间内没有受到确认，那么就重传这个报文段。</p><p>一个报文段发送到接收到确认所经过的时间称为返回时间RTT，加权平均返回时间RTTs就按如下</p><script type="math/tex; mode=display">RTTs=(1-a)*(RTTs)+a*RTT</script><p>其中，0&lt;=a&lt;1,RTTs随着a的增加容易受到RTT的影响。<br>超时时间RTO应该略大于RTTs，TCP使用的超时时间计算如下：</p><script type="math/tex; mode=display">RTO=RTTs+4*RTTd</script><p>其中RTT为偏差的加权平均值</p><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>窗口时缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口文段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置的窗口大小</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收，如果发送窗口做不的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是发送并且已确认的状态；接收窗口的华东类似，接收窗口做不字节已经发送确认并交付主机，就向右华东接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口受到的字节为{31,34,35},其中{31}按序到达，而{34，35}就不是，因此只对字节31进行确认。发送方得到一个字节的确认之后，就直到这个字节之前的所有字节都已被接收。</p><p><img src="/2019/08/30/net5/hudong.jpg" alt="hudogn"></p><p>参考：<a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——网络层</title>
      <link href="/2019/08/30/net4/"/>
      <url>/2019/08/30/net4/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用IP协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个同意的网络。</p><p>与IP协议配套使用的还有三个协议：</p><ul><li>地址解析协议APP(Address Resolution Protocol)</li><li>网际控制报文协议ICMP(Internet Control Message Protocl)</li><li>网际组管理协议IGMP(Internet Group Management Protocol)</li></ul><h2 id="IP数据包格式"><a href="#IP数据包格式" class="headerlink" title="IP数据包格式"></a>IP数据包格式</h2><p><img src="/2019/08/30/net4/IP.jpg" alt="IP"></p><ul><li>版本：有4(IPv4)和6(IPv6)两个值；</li><li>首部长度：占4位，因此最大值为15.值为1表示的是1个32位字的长度，也就是4个字节。因为固定部分长度位20字节，因此该值最小位5。如果可选字段的长度不是4字节的整数倍，就用尾部的填充部分来填充。</li><li>区分服务：用来获得更好的服务，一般情况下不使用</li><li>总长度：包括首部长度和数据部分长度</li><li>身存时间：TTL，它的存在是为了防止无法交付的数据包在互联网中不断兜圈子。以路由器跳数为单位，当TTL为0时就丢失数据报</li><li>协议：指出携带的数据应该上交给哪个协议进行处理，例如ICMP、TCP、UDP</li><li>首部检验和：因为数据包每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量</li><li>标识：在数据包长度过长从而发生分片的情况下，相同数据包的不同分片具有相同的标识符</li><li>片偏移：和标识符也一起，用于发生分片的情况。片偏移的单位8字节<br><img src="/2019/08/30/net4/ppy.png" alt="ppy"></li></ul><h2 id="IP资质编址方式"><a href="#IP资质编址方式" class="headerlink" title="IP资质编址方式"></a>IP资质编址方式</h2><p>IP地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的</p><p>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</p><p><img src="/2019/08/30/net4/ipfl.png" alt="ipfl"></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>通过主机号字段中拿一部分作为子网号，把两级IP地址划分为三级IP地址</p><p>IP地址::={&lt;网络号&gt;,&lt;子网号&gt;，&lt;主机号&gt;}</p><p>要使用子网，必须配置子网掩码。一个B类地址的默认子网掩码为255.255.0.0，如果B类地址的子网占两个比特，那么子网掩码为11111111 11111111 11000000 00000000，也就是255.255.192.0</p><blockquote><p>注意，外部网络看不到子网的存在</p></blockquote><h3 id="无分类"><a href="#无分类" class="headerlink" title="无分类"></a>无分类</h3><p>无分类编址CIDR消除了传统A类、B类和C类地址以及划分子网的概念，使用网络前缀和主机号来对IP地址进行编码，网络前缀的长度可以根据需要变化<br>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}<br>CIDR的记法上采用在IP地址后面加上网络前缀长度的方法，例如128.14.35.7/20表示前20位为网络前缀</p><p>CIDR的地址掩码可以继续称为子网掩码，子网掩码首长度1为网络前缀的长度</p><p>一个CIDR地址块中有很多地址，一个CIDR表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><p>参考：<a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——链路层</title>
      <link href="/2019/08/30/net3/"/>
      <url>/2019/08/30/net3/</url>
      
        <content type="html"><![CDATA[<h2 id="二、链路层"><a href="#二、链路层" class="headerlink" title="二、链路层"></a>二、链路层</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><h4 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束<br><img src="/2019/08/30/net3/zhen.png" alt="zhen"></p><h4 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样</p><p>帧首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么真的额开始和结束位置就会被错误判定。需要在数据部分出现首部尾部相同的内容插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以以还原出原始数据。这个过程透明传输的内容是转义字符。用户察觉不到转义字符的存在。<br><img src="/2019/08/30/net3/touming.png" alt="touming"></p><h4 id="3-差错检查"><a href="#3-差错检查" class="headerlink" title="3. 差错检查"></a>3. 差错检查</h4><p>目前数据链路层广泛使用了循环冗余检验(CRC)来检查比特差错</p><h3 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h3><h4 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h4><p>一对多通信，有一个节点发送的数据能被广播信道所偶的节点接收到</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突(冲突也叫碰撞)</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用CSMA/CD协议</p><h4 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h4><p>一对一通信<br>因为不会发生碰撞，因此也比较简单，使用PPP协议进行控制</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1. 频分复用"></a>1. 频分复用</h4><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源<br><img src="/2019/08/30/net3/fuyong.png" alt="fuong"></p><h4 id="2-时分复用"><a href="#2-时分复用" class="headerlink" title="2. 时分复用"></a>2. 时分复用</h4><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源<br><img src="/2019/08/30/net3/shifen.png" alt="shifen"><br>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让给其他用户使用，因此这两种方式对信道的利用率都不高</p><h4 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3. 统计时分复用"></a>3. 统计时分复用</h4><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就几种起来组成统计时分复用帧然后发送<br><img src="/2019/08/30/net3/tongji.png" alt="tongji"></p><h4 id="4-波分复用"><a href="#4-波分复用" class="headerlink" title="4. 波分复用"></a>4. 波分复用</h4><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址是链路层地址，长度为6字节(48位)，用于唯一标识网络适配器(网卡)</p><p>一台主机拥有多个网络适配器就拥有多少个MAC地址。例如笔记本普遍存在无线网络适配器和无线网络适配器，因此就有两个MAC地址。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网是一种典型广播信道，主要特点是网络为一个单位所拥有，且地理位置范围和站点数据均有限</p><p>主要有以太网、令牌环网、FDDI和ATM等具局域网技术，目前以太网占领着有线局域网市场。</p><p>参考：<a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——物理层</title>
      <link href="/2019/08/30/net2/"/>
      <url>/2019/08/30/net2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、物理层"><a href="#一、物理层" class="headerlink" title="一、物理层"></a>一、物理层</h2><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>跟据信息在传输线上的传送方向分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h3 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h3><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制就是把数字信号转换为模拟信号。</p><p>参考：<a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络——概述</title>
      <link href="/2019/08/29/net1/"/>
      <url>/2019/08/29/net1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>互联网服务提供商ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等互联网设备，个人或机构向ISP缴纳一定的费用就可以接入或联网。</p><h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>电路交换用于电话通信系统，两个用户要通信之前需要简历一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程不可能一直在使用传输线路，因此电路交换对线路的利用很低，往往不到10%。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个互相不会影响，因那次在同一条传输线路上允许同时传递多个分组，也就是分组交换不需要战越勇传输线路。</p><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把想用目的地邮件转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>总时延 = 排队时延+处理时延+传输时延+传播时延</p><h5 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h5><p>分组在路由器地输入队列和输出队列中排队等待地时间，取决于网络当前地通信量。</p><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><p>主机或路由器收到分组时进行处理所需要地时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当地路由等</p><h5 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h5><p>主机或路由器传输数据帧所需要地时间</p><script type="math/tex; mode=display">delay=l(bit) / v(bit/s)</script><p>其中l表示数据帧地长度，v表示传输速率</p><h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>电磁波在信道传播所需要花费地时间，电磁波传播地速度接近光速</p><script type="math/tex; mode=display">delay=l(m)/v(m/s)</script><p>其中l表示信道长度，v表示电磁波在信道上地传播速度</p><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="/2019/08/29/net1/net1.png" alt="net1"></p><h4 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h4><ul><li>应用层：为特定应用程序提供数据传输服务，例如HTTP、DNS等协议。数据单位为报文。</li><li>传输层：为进程提供数据传输服务，由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP，提供面向连接可靠的数据传输服务，数据单位为报文段；用户数据协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务。</li><li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程的提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据封装称分组。</li><li>数据链路层：网络成针对的还是主机之间的数据出书服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><ul><li>表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层：建立及管理会发</li></ul><p>五层协议美亚由表示层和会话层，而是将这些功能留给应用程序或者开发处理</p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>只有四层相当于五层协议中数据链路层和物理层合并为网络接口层。</p><h3 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h3><p>在向下的过程中，许哟啊添加下层协议所需要的首部和尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc</title>
      <link href="/2019/08/19/springmvc/"/>
      <url>/2019/08/19/springmvc/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><ul><li>Spring MVC 使用@RequestMapping注解为控制器指定可以处理哪些URL请求</li><li>在控制的<strong>类定义</strong>以及<strong>方法定义</strong>处都可标记<ul><li>类定义处：提供初步的请求映射信息。</li><li>方法处：提供进一步的细分映射信息。相对于类定义出的URL</li></ul></li><li><p>DispatcherServlet 截或请求后，就通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法。</p><blockquote><p>HTTP请求</p><ul><li>请求方法</li><li>请求URL</li><li>HTTP 协议记忆版本</li><li>报文头</li><li>报文体</li></ul></blockquote></li><li><p>@RequestMapping除了可以使用<strong>请求URL</strong>映射请求外，<strong>还可以使用请求方法、请求参数及请求头映射请求</strong></p></li><li>@RequestMapping的value、method、params及heads分别标识<strong>请求URL、请求方法、请求参数及请求头的映射条件</strong>，它们之间是<strong>与</strong>的关系联合使用多个条件可以让请求映射更加精确话。</li><li>params和headers支持简单的表达式：<ul><li>param1：表示请求必须包含为param1的请求参数</li><li>!param1: 表示请求不能包含名为param1的请求参数</li><li>param1 != value1: 表示请求包含名为param1的请求参数，但其值不能为value1</li><li>{“parma1=value1”,”param1”}：请求必须包含为param1和param2的两个请求参数，且param1的参数值为value1</li></ul></li></ul><h3 id="PathVariable-映射URL绑定的占位符"><a href="#PathVariable-映射URL绑定的占位符" class="headerlink" title="@PathVariable 映射URL绑定的占位符"></a>@PathVariable 映射URL绑定的占位符</h3><p>带占位符的URL式Spring3.0 新增的功能，该功能在SpringMVC向<strong>REST</strong>目标发展过程中具有里程碑的意义</p><p>通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法的形参中：URL中的{xxx}占位符可以通过@PathVariable(“xxx”)绑定到操作方法的形参中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"delete/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="function">UserDao <span class="title">delete</span><span class="params">(id)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/user/list.actrion"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST(Repersentational State Transfer)。资源表现层状态转化。是目前最流行的一种互联网软甲架构。它结构清晰、符合标准、已于理解、扩展方便，所以正得到越来越多的网站的采用</p><ul><li>资源（Resoucres): 网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文段、一张图片、一首歌曲、一直服务，总之就是一个具体的存在。一用一个URI(统一资源定位符)指向它，每种资源对应一个特定你的URI，要获取这个资源，访问它的URI就可以。因此URI即为每一个资源的duyiwuer的标识符。</li><li>表现层(Representation): 把资源具体呈现出来的形式，叫做它的表现层(Representation)。比如，文本可以用txt格式表现，也可以用HTML格式、XML<br>格式、JSON格式表现，甚至可以采用二进制格式</li><li>状态转换(State Transfer): 没发出一个请求，就代表领了刻划断和服务端的一次交互过程，HTTP协议，是一个状态写于一，即所有的状态都保存在服务端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务端发生”状态转化”。而 这种转换时简历在表现层之上的，所以就是“表现层状态转化”，具体说就是<strong>HTTP协议理面，四个表示操作方式的动词：GET、PUT、POST、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源、PUT用来更新资源、DELETE用来删除资源。</strong></li></ul><h2 id="请求处理方法签名"><a href="#请求处理方法签名" class="headerlink" title="请求处理方法签名"></a>请求处理方法签名</h2><ul><li>SpringMVC 通过分析处理方法的签名，将HTTP请求信息绑定到处理方法的响应形参中。</li><li>SpringMVC对控制器处理方法签名的限制时很宽松的，几乎可以按细化的任何方式对方法进行签名。</li><li>必要时可以对方法及方法形参标注响应的注解(@PathVariable、@RequestParam、@RequestHeader等)、SpringMVC框架会将HTTP请求的信息绑定到响应的方法形参中，并根据方法的返回值做出相应的后续处理。</li></ul><h2 id="使用POJO对象绑定请求参数值"><a href="#使用POJO对象绑定请求参数值" class="headerlink" title="使用POJO对象绑定请求参数值"></a>使用POJO对象绑定请求参数值</h2><p>SpringMVC会按请求参数名和POJO属性名进行你自动匹配，自动为该对象填充属性值。支撑级联属性，如：dept.deptId、dept.address.tel等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMaping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"SCUESS"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理模型数据"><a href="#处理模型数据" class="headerlink" title="处理模型数据"></a>处理模型数据</h2><p>SpringMVC提供了以下几种途径输出模型数据：</p><ul><li>ModelAndView：处理方法返回类型为ModelANdView时，方法体即可通过该对象添加模型数据</li><li>Map及Model：形参为org.sprignframework.ui.Model、org.springframework.ui.ModelMap或java.util.Map时，处理方法返回时，Map中的数据会自动添加到模型中</li><li>@SessionAttributes：将模型中的某个属性残存到HttpSession中，以便多个请求之间可以共享这个属性</li><li>@ModelAttribute：方法形参标注该注解后，形参的对象就会放到数据模型中。<blockquote><p>SpringMVC会把ModelAndView的model中数据放入到request域对象中</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>restful</title>
      <link href="/2019/08/14/restful/"/>
      <url>/2019/08/14/restful/</url>
      
        <content type="html"><![CDATA[<h2 id="设计概念和准则"><a href="#设计概念和准则" class="headerlink" title="设计概念和准则"></a>设计概念和准则</h2><ul><li>网络上的所有事物都可以抽象为资源</li><li>每一个资源都有唯一的资源表示，对资源的操作不会改变这些标识。</li><li>所有的操作都是无状态的。</li></ul><h2 id="HTTP协议——URL"><a href="#HTTP协议——URL" class="headerlink" title="HTTP协议——URL"></a>HTTP协议——URL</h2><p>HTTP使一个属于应用层的协议，特点是简洁、快速</p><h2 id="HTTP协议——请求"><a href="#HTTP协议——请求" class="headerlink" title="HTTP协议——请求"></a>HTTP协议——请求</h2><p>组成格式：请求行、消息报头、请求正文</p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p><code>Method Request-URI HTTP-Version CRLF</code></p><p>举例<br><code>GET/HTTP/1.1 CRLF</code></p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul><li>GET: 请求获取Request——URL所标识的资源</li><li>POST：在Request-URI所标识的资源后附加新的数据</li><li>HEAD：请求获取由Request——URI所表示的资源的响应消息报头</li><li>PUT： 请求服务器存储一个资源，并用Request—URI作为其标识</li><li>DELETE：请求服务器删除Request-URI所标识的资源</li><li>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul><h2 id="HTTP协议-响应"><a href="#HTTP协议-响应" class="headerlink" title="HTTP协议-响应"></a>HTTP协议-响应</h2><p>组成格式：状态行、消息报头、响应正文</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p><code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br><code>HTTP/1.1 200 OK</code></p><h3 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h3><ul><li>200  OK  ：客户端请求成功</li><li>300  Bad Request : 客户端请求有语法错误，不能被服务器所理解</li><li>401  Unauthorized ： 服务器收到请求，但是拒绝提供服务</li><li>404  Not Found ： 请求资源不存在</li><li>500  Internal Server Error ： 服务器发生不可预期的错误</li><li>503  Server Unavaiable ： 服务器当前不能处理客户端的请求</li></ul><h2 id="如何设计RESTful-API"><a href="#如何设计RESTful-API" class="headerlink" title="如何设计RESTful API"></a>如何设计RESTful API</h2><h3 id="资源路径"><a href="#资源路径" class="headerlink" title="资源路径"></a>资源路径</h3><p>在RESTful架构中，每个网址代表一种资源，所以王志忠不能有动词，只能有名词，一般来说API中的名词应该使用复数</p><h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><ul><li>GET: 请求获取Request——URL所标识的资源</li><li>POST：在Request-URI所标识的资源后附加新的数据</li><li>PUT： 请求服务器存储一个资源，并用Request—URI作为其标识</li><li>DELETE：请求服务器删除Request-URI所标识的资源</li><li>PATCH：</li></ul><h3 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h3><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2019/08/05/MySql/"/>
      <url>/2019/08/05/MySql/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><ol><li>DB：数据库，保存一组有组织的数据容器</li><li>DBMS：数据库管理系统，又称为数据库软件，用于管理DB中的数据。</li><li>SQL：结构化查询语言，用于和DMBS通信的语言</li></ol><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>启动服务<br><code>net start mysql</code></li><li>关闭服务<br><code>net stop mysql</code></li><li>登录<br><code>mysql [-h 地址 -p 端口号] -u 用户名 -p 密码</code></li><li>退出<br><code>exit或ctrl+C</code></li></ul><h2 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h2><ol><li>不区分大小写，但建议关键词大写，表明、列名小写</li><li>每条命令最好分号结尾</li><li>每条命令根据需要，可以进行缩进或换行</li><li>注释<ul><li>单行注释：#注释文字   </li><li>多行注释：—注释文字</li><li>多行注释：/<em> 注释文字 </em>/ </li></ul></li></ol><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><ol><li>DQL(Data Query Language)：数据查询语言<br><code>select</code></li><li>DML(Data Manipulate Language)：数据操作语言<br><code>insert、update、delete</code></li><li>DDL(Data Define Language): 数据定义语言<br><code>create、drop、alter</code></li><li>TCL(Transaction Control Language): 事物控制语言<br><code>commit、rollback</code></li></ol><h3 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>使用<code>SELECT</code>语句从表或视图获取数据。表由行和列组成，如电子表格。 通常，我们只希望看到子集行，列的子集或两者的组合。<code>SELECT</code>语句的结果称为结果集，它是行列表，每行由相同数量的列组成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    表名</span><br></pre></td></tr></table></figure><p>通过select查询完的结果，是一个虚拟的表格，不是真实存在的</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>根据条件过滤原始表的数据，查询到想要的数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    条件</span><br></pre></td></tr></table></figure></p><p>下列表列出了可用于在<code>WHERE</code>子句中形成过滤表达式的比较运算符<br>操作符 | 描述<br>— | —<br><code>=</code> | 等于，几乎任何数据类型都可以使用它<br><code>&lt;&gt;</code> 或<code>!=</code> | 不等于<br><code>&lt;</code> | 小于，通常使用数字和日期/事件数据类型<br><code>&gt;</code> | 大于<br><code>&lt;=</code> | 小于或等于<br><code>&gt;=</code> | 大于或等于<br><code>and(&amp;&amp;)</code> | 两个条件如果同时成立，结果为true，否则为false<br><code>or(||)</code> | 两个条件只要有一个成立，结果为true，否则为false<br><code>not(!)</code> | 如果条件成立，则not后为false，否则为true</p><p>还有一些有用的运算符可以在<code>WHERE</code>子句中使用来形成更复杂的条件，例如：</p><ul><li><a href="#####BETWEEN">BETWEEN</a>: 选择在更定范围内的值</li><li><a href="#####LIKE">LIKE</a>:匹配基于模式匹配的值</li><li><a href="#####IN">IN</a>: 指定值是否匹配列表中的任何值</li><li><code>IS NULL</code>: 检查该值是否为<code>NULL</code></li></ul><h5 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h5><p>BETWEEN运算符允许指定要测试的值范围。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">BETWEEN</span> <span class="number">90</span> <span class="keyword">AND</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>也可以通过使用大于或等于(&gt;=)和小于或等于(&lt;=)运算符来实现相同的结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line">    A&gt;=<span class="number">90</span> <span class="keyword">AND</span> A&lt;=<span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>要查找A不在20到100(含20到100)之间的，可将BETWEEN运算符与NOT运算符组合使用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line">    A <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line">    A &lt; <span class="number">20</span> <span class="keyword">OR</span> buyPrice &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><h5 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h5><p>LIKE操作符通常用于基于模式查询选择数据。以正确的方式使用LIKE运算符对于增加/减少查询性能至关重要。</p><ul><li>% ：允许匹配任何字符串的零个或多个字符</li><li>_ : 允许匹配任何单个字符</li></ul><p>假设要搜索名字以字符a开头的员工信息，可以在模式末尾使用百分比通配符(％)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    column1,column2,...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    column1 <span class="keyword">LIKE</span> <span class="string">'a%'</span>;</span><br></pre></td></tr></table></figure></p><p>如果知道要搜索包含指定字符串，则可以在模式的开头和结尾使用百分比(%)通配符。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    column1,column2,...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    column1 <span class="keyword">LIKE</span> <span class="string">'%on%'</span>;</span><br></pre></td></tr></table></figure></p><p>要查找名字以T开头的员工，以m结尾，并且包含例如Tom，Tim之间的任何单个字符，可以使用下划线通配符来构建模式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    column1,column2,...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    column1 <span class="keyword">LIKE</span> <span class="string">'T_m'</span>;</span><br></pre></td></tr></table></figure></p><ul><li>MySQL允许将NOT运算符与LIKE运算符组合，以找到不匹配特定模式的字符串。  </li><li>有时想要匹配的模式包含通配符，例如10%，_20等这样的字符串时。在这种情况下，您可以使用ESCAPE子句指定转义字符，以便MySQL将通配符解释为文字字符。如果未明确指定转义字符，则反斜杠字符\是默认转义字符。</li></ul><h5 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h5><p>IN运算符允许您确定指定的值是否与列表中的值或子查询中的任何值匹配。 下面说明了IN操作符的语法。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    column1,column2,...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    (expr|column_1) <span class="keyword">IN</span> (<span class="string">'value1'</span>,<span class="string">'value2'</span>,...);</span><br></pre></td></tr></table></figure></p><p>下面我们更详细的来看看上面的查询</p><ul><li>可以在<code>WHERE</code>中于<code>IN</code>运算符一起使用，也可以使用列或表达式(expr)</li><li>列表中的值必须用逗号(<code>,</code>)隔开</li><li><code>IN</code>操作符可以用在其他语句(如<code>INSERT</code>,<code>UPDATE</code>,<code>delete</code>)的WHERE子句中</li><li>如果column_1的值或expr表达式的结果等于列表中的任何值，则IN运算符返回1，否则返回0。</li></ul><blockquote><p>如果column_1的值或expr表达式的结果等于列表中的任何值，则IN运算符返回1，否则返回0。</p></blockquote><h6 id="IN与子查询"><a href="#IN与子查询" class="headerlink" title="IN与子查询"></a>IN与子查询</h6><p><code>IN</code>运算符通常用于子查询。子查询不提供常量值列表，而是提供值列表。<br>我们来看两张表：<code>orders</code>和<code>orderDetails</code>表的结构以及它们之间的关系：<br><img src="/2019/08/05/MySql/in.png" alt="in"><br>例如，如果要查找总金额大于60000的订单，则使用<code>IN</code>运算符查询如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    orderNumber, customerNumber, <span class="keyword">status</span>, shippedDate</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    orderNumber <span class="keyword">IN</span> (<span class="keyword">SELECT</span> </span><br><span class="line">            orderNumber</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            orderDetails</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber</span><br><span class="line">        <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(quantityOrdered * priceEach) &gt; <span class="number">60000</span>);</span><br></pre></td></tr></table></figure></p><p>上面的整个查询可以分为2个查询</p><ol><li>首先，子查询使用<code>orderDetails</code>表中的<code>GROUP BY</code>和<code>HAVING子句</code>返回总额大于60000的订单列表。</li><li>主查询<code>order</code>表中获取数据，并在<code>WHERE</code>子句中应用<code>IN</code>运算符</li></ol><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段|表达式|常量值|函数</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tableName</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    排序的字段|表达式|函数|别名【<span class="keyword">asc</span>|<span class="keyword">desc</span>】</span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    查询的字段，分组函数</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    分组的字段</span><br></pre></td></tr></table></figure><ul><li>可以按单个字段分组</li><li>和分组函数一同查询的字段最好是分组后的字段    </li></ul><p>特点：</p><ol><li>分组查询中的筛选条件分为两类  </li></ol><div class="table-container"><table><thead><tr><th>分组筛选</th><th>针对的表</th><th>位置</th><th>关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by的前面</td><td>where</td></tr><tr><td>分组后的筛选</td><td>分组后的结果集</td><td>group by的后面</td><td>having</td></tr></tbody></table></div><ol><li>可以按多个字段分组，字段之间用逗号隔开</li><li>可以支持排序(排序放在整个分组查询后面    )</li><li>having后可以支持别名</li></ol><h5 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h5><p><div><br>    <table>        <tr>            <th colspan="2">单行函数</th>            <th>含义</th>             </tr>        <tr>            <td rowspan="12">字符函数</td>            <td>concat</td>            <td>拼接</td>        </tr>        <tr>            <td>substr</td>            <td>截取子串</td>        </tr>        <tr>            <td>upper</td>            <td>转换成大写</td>        </tr>        <tr>            <td>lower</td>            <td>转换成小写</td>        </tr>        <tr>            <td>trim</td>            <td>去前后指定的空格和字符</td>        </tr>        <tr>            <td>ltrim</td>            <td>去左边空格</td>        </tr>        <tr>            <td>rtrim</td>            <td>去右边空格</td>        </tr>        <tr>            <td>replace</td>            <td>替换</td>        </tr>        <tr>            <td>replace</td>            <td>替换</td>        </tr>        <tr>            <td>lpad</td>            <td>左填充</td>        </tr>        <tr>            <td>rpad</td>            <td>右填充</td>        </tr>        <tr>            <td>instr</td>            <td>返回字串第一次出现的索引</td>        </tr>        <tr>            <td rowspan="6">数学函数</td>            <td>round</td>            <td>四舍五入</td>        </tr>        <tr>                <td>rand</td>            <td>随机数</td>        </tr>        <tr>              <td>floor</td>            <td>向下取整</td>        </tr>        <tr>            <td>ceil</td>            <td>向上取整</td>        </tr>        <tr>            <td>mod</td>            <td>取余</td>        </tr>        <tr>            <td>ceil</td>            <td>截断</td>        </tr>        <tr>            <td rowspan="5">日期函数</td>            <td>now</td>            <td>当前系统日期+时间</td>        </tr>        <tr>            <td>curdate</td>            <td>当前系统日期</td>        </tr>        <tr>            <td>curtime</td>            <td>当先系统时间</td>        </tr>        <tr>            <td>str_to_date</td>            <td>将字符转换成日期</td>        </tr>        <tr>            <td>date_format</td>            <td>将日期准换成字符</td>        </tr>        <tr>            <td rowspan="2">流程控制函数</td>            <td>if</td>            <td>处理双分支</td>        </tr>        <tr>            <td>case</td>            <td>处理多分支</td>        </tr>        <tr>            <td rowspan="3">其他函数</td>            <td>version</td>            <td>版本</td>        </tr>        <tr>            <td>database</td>            <td>当前库</td>        </tr>        <tr>            <td>user</td>            <td>当前连接用户</td>        </tr>        <tr>            <td rowspan="4">分组函数</td>            <td>sum</td>            <td>求和</td>         </tr>        <tr>            <td>max</td>            <td>最大值</td>         </tr>        <tr>            <td>min</td>            <td>最小值</td>         </tr>        <tr>            <td>avg</td>            <td>平均值</td>         </tr>    </table></div></p><div><blockquote><ol><li>以上五个分组函数都忽略null值，除了count(*)</li><li>sum和avg一般用于处理数值型；max、min、count可以任何数据类型</li><li>都可以搭配DISTINCT使用，用于统计去重后的结果</li><li>count的参数可以支持字段、’*、常量值、一般放1</li></ol></blockquote><p>参考：【易百教程】：<a href="https://www.yiibai.com/mysql/sql-in.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/sql-in.html</a></p><h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><p>笛卡尔积：没有连接条件表关系返回的结果</p><p>连接用于连接多个表，使用JOIN关键字，并且条件语句使用ON而不时WHERE。连接可以替换子查询，并且比子查询的效率一般会更快。可以用AS给列名、计算字段和表名取别名，给表明取别名是为了简化SQL语句及连接相同表。</p><p>连接：</p><ul><li>内连接<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接 <ul><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li><li>交叉连接</li></ul><h5 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接(INNER JOIN)"></a>内连接(INNER JOIN)</h5><p><code>INNER JOIN</code>子句将一个表中的行与其他表中的行进行匹配，并允许从两个表中查询包含列的行记录。<br>在使用时，必须指定以下条件：</p><ul><li>首先，在FROM子句中指定主表</li><li>其次，表中要连接的主表应该出现在<code>INNER JOIN</code>子句中。理论上说，可以连接多个其他表。但是，为了获得更好的性能，应该限制要连接的表的数量(不超过3个表)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    查询列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表<span class="number">1</span> 别名</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">ON</span>  </span><br><span class="line">    连接条件</span><br></pre></td></tr></table></figure></li></ul><p>可以不明确使用<code>INNER JOIN</code>,而使用普通查询在<code>WHERE</code>中两个表要连接的列用等值方法连接起来<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A.value,B.value</span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure></p><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>自连接可以看成内连接的一种，知识连接的表是自身而已<br>一张员工表，包含员工姓名和员工所属部门，要找出Jim处在同一部门的所有成员姓名<br>子查询版本：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    namea</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    department=(</span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            department</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            employee</span><br><span class="line">        <span class="keyword">WHERE</span> </span><br><span class="line">            namea=<span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure></p><p>自连接版本<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    e1.name</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">   employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">    e1.department = e2.department</span><br><span class="line"><span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure></p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接查询会返回操作表中至少一个表的所有数据记录</p><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>指新关系执行匹配时，以关机再LEFT JOIN左边的标为参考表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段，...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表<span class="number">1</span>，</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">    连接条件</span><br></pre></td></tr></table></figure></p><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>指新关系执行匹配时，以关机再RIGHT JOIN左边的标为参考表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    字段，...</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表<span class="number">1</span>，</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">    连接条件</span><br></pre></td></tr></table></figure></p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是嵌套在另一个查询中的查询，子查询称为内部查询，而包含子查询的查询称为外部查询。子查询可以在使用表达式的任何地方使用，并且必须在括号中关闭。MySQL推荐使用子查询来实现多表查询数据记录，不建议使用连接查询。</p><p>特点：</p><ul><li>子查询都放在小括号内</li><li>子查询可以放在from后面、select后面、where后面、having后米娜、但一般放在条件的右侧</li><li>子查询优先于主查询执行，主查询使用了子查询的执行结果</li><li>子查询根据查询结果的行数不同分为以下两类：<ol><li>单行子查询<ul><li>一般结果集只有一行</li><li>一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=</li><li>非法使用子查询的情况<ul><li>子查询的结果为一组值</li><li>子查询的结果为空</li></ul></li></ul></li><li>多行子查询<ul><li>结果集有多行</li><li>一般搭配多行操作符使用：and、all、in、not in</li><li>in：属于子查询结果中的任意一个就行，any和all往往可以用其他查询代替</li></ul></li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    mytable1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    col1 </span><br><span class="line"><span class="keyword">IN</span>  </span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        col2</span><br><span class="line">    <span class="keyword">FROM</span>    </span><br><span class="line">        mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</p><p>语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    column1,....</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    表</span><br><span class="line">【<span class="keyword">WHERE</span> 条件】</span><br><span class="line">【<span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段】</span><br><span class="line">【<span class="keyword">HAVING</span> 条件】</span><br><span class="line">【<span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序的字段】</span><br><span class="line"><span class="keyword">limit</span>   【其实的条目索引】条目数；</span><br></pre></td></tr></table></figure></p><p>特点</p><ul><li>起始条目索引从0开始</li><li>limit子句放在查询语句的最后</li><li>公式：SELECT <em> FROM LIMIT (page - 1) </em> sizePerPage，siezPerPage</li></ul><p>假如：<br>每页显示条目数：sizePerPage<br>要显示的页数 page</p><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>特点：<br>    1、多条查询语句的查询的列数必须是一致的<br>    2、多条查询语句的查询的列的类型几乎相同<br>    3、union代表去重，union all代表不去重</p><h3 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1,col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1,val2)</span><br></pre></td></tr></table></figure><p>插入检索出来的数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure></p><p>将一个表的内容插入到一个新表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure></p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>添加列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><p>删除列<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>；</span><br></pre></td></tr></table></figure></p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><h4 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h4><p>创建库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 库名</span><br></pre></td></tr></table></figure></p><p>创建表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] mytable(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    col2 <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span>,</span><br><span class="line">    col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><ul><li>NOT NULL</li><li>DEFAULT</li><li>UNIQUE</li><li>CHECK</li><li>PRIMARY KEY</li><li>FOREIGN KEY</li></ul><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h4 id="事物的ACID属性"><a href="#事物的ACID属性" class="headerlink" title="事物的ACID属性"></a>事物的ACID属性</h4><ol><li>原子性(Atomicity)<br>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。<blockquote><p>回滚可以利用回滚日志来实现，回滚日志记录者所执行的修改操作，在回滚时反向执行这些操作即可。</p></blockquote></li><li><p>一致性(Consistency)<br>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p></li><li><p>隔离性(lsolation)<br>一个事务所做的修改最终在提交以前，对其他事务时不可见的。</p><ol><li>持久性(Durablility)<br>一旦事务提交，则其所作的修改会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。</li></ol><hr><p>事务的ACID特性概念简单，大怒是很好理解，只要是因为这几个特新不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满徐隔离性，才能满足一致性。</li><li>事务满足持久话是为了能够应对数据困崩溃的情况。<br><img src="/2019/08/05/MySql/acid.png" alt="acid"></li></ul></li></ol><h4 id="1-AUTOCOMMIT"><a href="#1-AUTOCOMMIT" class="headerlink" title="1 AUTOCOMMIT"></a>1 AUTOCOMMIT</h4><p>MySQL默认采用自动提交模式。也就是说，如果不显示使用<code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询都会被当作一个事务自动提交</p><h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><p>在并发环境下，事务的隔离性很难保证，也因此会出现很多并发一致性问题。</p><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><p>T1和T2两个事务都对一个数据惊醒修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改<br><img src="/2019/08/05/MySql/fugai.png" alt="fugai"></p><h5 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h5><p>T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据就是脏数据<br><img src="/2019/08/05/MySql/zangdu.png" alt="zangdu"></p><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同<br><img src="/2019/08/05/MySql/bukechongfu1.png" alt="bukechongfu"></p><h5 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h5><p>T1读取某个范围的数据，T2再这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。<br><img src="/2019/08/05/MySql/huanying.png" alt="bukechongfu"></p><hr><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，结局方法是通过并发控制来保证隔离性。并发控制通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>MySql中提供了两种封锁粒度：<strong>行级锁和表级锁</strong><br>应该尽量锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销开销就越大。</p><h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><ol><li>读写锁<ul><li>排它锁(Exclusive),简写为X锁，又称写锁</li><li>共享锁(Shared),简称为S锁，又称读锁</li></ul></li></ol><p>有以下两个规定：</p><ul><li>一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其它事务不能对A加任何锁。</li><li>一个事务对数据对象A加了S锁，可以对A进行读取操作，但不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。</li></ul><p>锁的兼容关系如下</p><div class="table-container"><table><thead><tr><th>-</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>x</td><td>x</td></tr><tr><td>S</td><td>x</td><td>√</td></tr></tbody></table></div><ol><li>意向锁<br>使用意向锁(Intention Locks)可以更容易地支持多粒度封锁</li></ol><p>再存在行级锁和表级锁的情况下，事务T想要对表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，这是非常耗时的。</p><p>意向锁再原来的X/S锁上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要再表中的某个数据行加上X锁或S锁。有以下两个规定：</p><ul><li>一个事务再获得某个数据对象的S锁之前，必须现货的表的IS锁或者更强的锁；</li><li>一个事务再获得数据对象的X锁之前，必须先获得表的IX锁。</li></ul><p>通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/IS锁，如果加了就表示有其他事务证字啊使用这个表或者表中的某一行的锁，因此事务T加X锁失败</p><p>各种锁的兼容关系如下：</p><div class="table-container"><table><thead><tr><th>-</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>x</td><td>x</td><td>x</td><td>x</td></tr><tr><td>IX</td><td>x</td><td>√</td><td>x</td><td>√</td></tr><tr><td>S</td><td>x</td><td>x</td><td>√</td><td>√</td></tr><tr><td>IS</td><td>x</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><p>解释如下：</p><ul><li>热议IS/IX锁之间都是兼容的，因为它们知识表示想要对表加锁，而不是真正加锁；</li><li>S锁只与IS锁兼容，也就是说事务T想要对数据加S锁，其他事务可以获得对表或者表中的行的S锁。</li></ul><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><p>在要运用X锁和S锁对数据对象加锁时，还需要约定一些规则，我们称之为<strong>封锁协议</strong></p><ol><li>三级封锁协议<br>1.1 一级封锁协议<br>事务T要修改数据A时必须加X锁，直到T结束才释放锁</li></ol><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，哪个事务的修改就不会被覆盖。</p><p>T1 | T2<br>|— | —|<br>|lock-x(A) | |<br>|read A = 20 | |<br>|   | lock-x(A)|<br>|   | wait |<br>|write A=19 | |<br>|commit | |<br>|unlock-x(A) | |<br>|   | obtain |<br>|   | read A=19 |<br>|   | write A=21 |<br>|   | commit |<br>|   | unlock-x(A) |</p><p>1.2 二级封锁协议<br>在一级的基础上，要求读取数据A时必须jiaS锁，读取完马上释放S锁</p><p>可以解决读脏数据问题，因为一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入数据</p><div class="table-container"><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>lock-x(A)</td><td></td></tr><tr><td>read A=20</td><td></td></tr><tr><td>write A=19</td><td></td></tr><tr><td></td><td>lock-s(A)</td></tr><tr><td></td><td>wait</td></tr><tr><td>rollback</td><td></td></tr><tr><td>A=20</td><td></td></tr><tr><td>unlock-x(A)</td><td></td></tr><tr><td></td><td>obtain</td></tr><tr><td></td><td>read A=20</td></tr><tr><td></td><td>unlock-s(A)</td></tr><tr><td></td><td>commit</td></tr></tbody></table></div><p>1.3 三级封锁协议<br>在一级的基础上，要求读数据A时必须加S锁，直到事务结束了才能释放S锁。可以解决不可重复度的问题，因为读A时，其他事务不能对A加X锁，从而笔迷拿了在读的期间数据发生变化<br>| T1 | T2 |<br>| — | — |<br>| lock-s(A)    | |<br>| read A=20    | |<br>| | lock-x(A)|<br>| | wait|<br>| read A=20    | |<br>| commit | |<br>|unlock-s(A) | |<br>| | obtain|<br>| | read A=20 |<br>| | write A=19 |<br>| | commit |<br>| | unlock-X(A) |</p><blockquote><p>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放锁</p></blockquote><ol><li>两段锁协议<br>加锁和解锁分为两个阶段进行</li></ol><p>可串行化调度室指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行话调度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure></p><p>但不是必要条件，例如如下操作不满足两段锁协议，但是他还是可串行化调度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure></p><h4 id="MySQL隐式与显示锁定"><a href="#MySQL隐式与显示锁定" class="headerlink" title="MySQL隐式与显示锁定"></a>MySQL隐式与显示锁定</h4><p>MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在所需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</p><p>InnoDB也可以使用特定的语句进行显示锁定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong></p></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理必知的20个数据指标</title>
      <link href="/2019/08/03/pm20/"/>
      <url>/2019/08/03/pm20/</url>
      
        <content type="html"><![CDATA[<h2 id="广告指标"><a href="#广告指标" class="headerlink" title="广告指标"></a>广告指标</h2><p>不同时期产品的宣传要选择合适的投放媒体和渠道，这就是要我们了解基本的广告指标数据</p><h3 id="CPM"><a href="#CPM" class="headerlink" title="CPM"></a>CPM</h3><p>cost per impression， 按前次展示付费，指通过某一媒体投放广告，听到或看到此广告的人道道一千人平均所要花费的广告费用  </p><script type="math/tex; mode=display">CPM = (广告人数/到达人数) \times 1000</script><p>比如投入广告费用200元，有10000人浏览过此广告，则</p><script type="math/tex; mode=display">CPM = (200/100000) \ times 1000 = 20元</script><p>CPM取决于产品的印象，不是评价广告效果的单一指标，是不同媒体进行衡量而指定的一个相对指标，通过比较不同渠道的广告收入找出效果最好的渠道。</p><h3 id="CPA"><a href="#CPA" class="headerlink" title="CPA"></a>CPA</h3><p>cost per action,按照广告使用户产生一定行为而计费，不限广告投放量，对于用户行为的定义依产品而定，包括形成一次交易、获得一个注册用户、下载一次软件、或是填写一次有效问卷等，这些统称为用户行为转化。</p><script type="math/tex; mode=display">CPA=广告费用/有效转化次数</script><p>转化次数的统计较为困难，另外由于广告被点击后会触发用户后续行为(如注册或消费行为),在网站中不大受欢迎。</p><h3 id="CPC"><a href="#CPC" class="headerlink" title="CPC"></a>CPC</h3><p>cost per click,按点击量付费，对某一广告点击所产生的广告费用，统计点击量可以设定一定标准，比如对于同一个IP，在一个时间段内重复点击，统计为一次，也可忽略IP的限制，直接统计总点击量。</p><script type="math/tex; mode=display">CPC=广告费用/点击量</script><p>CPC为网络广告投放效果的重要参考数据，但也有其缺陷，比如虽然用户没有点击广告，但他已经看到了广告。</p><h3 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h3><p>cost per sales,按销售付费，按照广告点击之后产生的实际销售必输来计算广告费用，</p><script type="math/tex; mode=display">CPS=广告费用/有效销售量</script><p>适合购物类、导购类、网址导航类网站，需要精确的流量才能带来转化。</p><h3 id="CPT"><a href="#CPT" class="headerlink" title="CPT"></a>CPT</h3><p>cost per try，按试用次数付费，主要是移动应用的渠道营销平台可以十万或使用为付费标准。</p><script type="math/tex; mode=display">CPT=广告费用/有效使用次数</script><p>则会中方式的特点是按用户使用时常或使用周期计费，可以从根本上杜绝刷流量，是最真实有效快捷的营销方式之一。</p><h2 id="网页指标"><a href="#网页指标" class="headerlink" title="网页指标"></a>网页指标</h2><h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><p>page view,即页面浏览量，用户每次对网站中的每个网页访问均被记录为1次。用户对同一页面的多次访问，访问累计。在一定统计周期内用户每次刷新一次也被计算一次。通过后台运营获得数据；也可通过相关统计工具获得，如Google Analysis、百度统计等。日均IP/PV访问量的意思是今天访问首页次数为2400次，访问IP为600个，也就是说这600个IP一共访问网站2400次。一般来说PV与来访者数量成正比，但是PV并不直接决定页面的真实访问数量，例如，同一个来访者通过不断的刷新页面，也可以制造出非常高的PV</p><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p>Unique Visitor，即独立访客，访问网站的一台电脑客户端为一个方可。每天相同的客户端只被计算一次。使用独立用户作为统计量，可以更加准确了解单位时间有多少个访问者来到相应的页面。</p><h3 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h3><p>pagerank,即网页的级别安装Google Analytics等统计工具一个PR值为1的网站表明这个网站不太具有流行度，而PR值7到10表明这个网站非常受欢迎。</p><h3 id="跳出率"><a href="#跳出率" class="headerlink" title="跳出率"></a>跳出率</h3><p>指用户到达你的万盏上并在你的网站上仅浏览了一个页面就离开的访问次数与所有访问次数的百分比。这里的访问次数其实就是指PV。</p><script type="math/tex; mode=display">浏览单页即退出的次数/访问次数$$ 比如在一个统计时间内，一个网站有1000个不同访客从某一链接进入，并且其中有50个人没有二次浏览型为，是直接退出网站的，则针对这个链接的万盏跳出率为50/1000=5%。然而有些退出的型为不能作为退出考虑，比如页面上可以添加的导出链接，如合作伙伴的网站等，还有联系我们，付款页面等，都不算是负面的跳出，所以要根据不同情况统计有效的数据才能得出可靠的跳出率。是评价一个网站性能的重要指标，跳出率高，说明用户体验做的不好，用户进去就跳出去了，网站没有满足用户的期望与需求或是人群定位不精准，反之如果跳出率较低，说明万盏用户体验做的还不错，用户能够找到自己需要的内容。而且以后他可能还会光顾你的网站，提高了用户粘性。慢慢的可以积累大量的网站用户。### 退出率对某一个特定的页面而言，从这个页面离开网站的访问次数占所有浏览到这个页面的访问数的百分。$$从该页退出的页面访问数/进入该页的页面访问访问数$$ 可采用统计工具进行统计，从某方面反映了网站对于访客的吸引力，如果退出百分比很高，说明访客仅浏览少量的页面便离开了，因此当你的网站退出百分比很高的时候就要想办法改善你网站的内容来吸引访客了。> 跳出率适用于访问的着陆页(用户访问的第一个页面),而推出率则适用于任何访问退出的页面(访问过程中在你的网站上访问的最后一个页面)。退出率是对于特定的页面来说的，对于网站整体来说并无意义，因为来到网站的访问必然最终都会离开网站，对于网站整体来说退出率必然是100%。而跳出率则可以适用于着陆页面，也可使用万盏整体。### 平均访问时长指在一定统计时间内，浏览网站的一个页面或整个网站时用户所逗留的总时间与该页面或整个网站的访问次数的比。访问总时长/访问次数，如一个网站在一定时间内总的逗留时间为1000秒，在这段时间内，总的访问次数时100次，那么这个页面或网站的平均访问时长就是1000/100=10秒。是体现被统计用户的用户粘性的重要指标之一，进而可以评估万盏的用户体验，体验改善页面。平均访问时长越短，说明网站对用户的吸引力越差，可用的有用信息越少，也说明网站需要优化或都添加有用信息了### 转换率指在一个统计周期内，完成转化行为的次数占推广信息总点击次数的比。转换率=(转换次数/点击率) * 100%.以用户登陆为例，如果没100次访问中，就有10个登陆网站，那么此网站的登陆转化率九尾10%，而最后有两个用户订阅，则订阅转换率为2%，有一个用户下订单购买，则购买转换率为1%，转换率反映了网站的盈利能力，重视和研究网站转换率，可以针对性分析网站在哪些方面做的不足，哪些广告投放效果比较好，可以迅速的提升用户体验、节约广告成本，提升网络转换过程### 重复购买率指消费者对品牌产品或者服务的重复购买次数。重复购买率有两种计算方法：一种是 所有购买过产品的顾客，以每个人为独立单位重复购买产品的次数，比如有10个客户购买了产品，5个产生了重复购买，则重复购买率为50%；第二种算法是，单位时间内，重复购买的总次数占比，比如10个客户购买了产品，中间有3个人二次购买，这三个中的1个人又有了三次购买，则重复购买次数为4此，重复购买率为40%。## 用户指标### ARPUAverage Revenue Per User，即每用户平均收入在一定时间内，$$ARPU=总收入/用户数</script><p>一般是计算长期的ARPU比较有意义，如平均每月每用户收入。而总户数可以是总平均在线用户数、付费用户数或是活跃用户数，不同产品标准可能存在差别。ARPU注重的是一个时间段内从每个用户所得到的收入，衡量互联网公司业务收入的指标。ARPU值高说明平均每个用户贡献的收入高，但高未必说明利润高，因为利润还需要考虑成本。ARPU的高低没有绝对的好坏之分，分析的时候需要一定的标准</p><h3 id="用户流失率"><a href="#用户流失率" class="headerlink" title="用户流失率"></a>用户流失率</h3><p>是指哪些曾经使用过产品或服务，由于对用户产品时区兴趣等种种原因，不再使用产品或服务的用户。用户流失率=总流失用户数/总用户数，流失用户数依产品而定，并且有各自的不同标准。分析用户的流失情况可以找到流失原因，针对产品所处的时期再找到解决方法。一般流失用户都都是对于哪些需要注册、提供应用服务的网站而言的，比如微博、邮箱、电子商务类网站等。对于流失用户的界定依照产品服务的不同标准不同，对于微博和邮箱这类用户几乎每天登陆查看的网战而言，可用用户未登陆超过1个月，我们就可以任务用户可能已经流失了；而对于电子上午而言，可能3个月未登陆或半年内没有任务购买型为的用户可以被认定是流失用户。因此这里有个流失期限。</p><h3 id="活跃用户"><a href="#活跃用户" class="headerlink" title="活跃用户"></a>活跃用户</h3><p>是相对于“流失用户”的一个概念，是指那些会时不时地光顾网站，并未网站带来一些价值的用户。<br>活跃用户用户衡量网站的运营现状，而流失用户则用户分析网站是否存在被淘汰的风险，以及网站是否有有能力留住新用户。<br>每个产品活跃的定义千差万别，如果是有账号的客户端，通常以账号登陆作为活跃表示。。如果是某些工具软件，有的以启动作为活跃，例如看天气的，有需要进行一些核心操作，例如拍照软件，至少是完成一张照片拍摄，才能算活跃吧</p><h3 id="日活跃用户"><a href="#日活跃用户" class="headerlink" title="日活跃用户"></a>日活跃用户</h3><p>DAU，Daily Active User，指某个自然日内启动过应用的用户，该日内的多次启动只记一个活跃用户。</p><h3 id="月活跃用户"><a href="#月活跃用户" class="headerlink" title="月活跃用户"></a>月活跃用户</h3><p>MAU，Monthly Active User，指某个自然月启动过应用的用户，该月内的多次启动只记一个活跃用户。</p><h3 id="周活跃用户"><a href="#周活跃用户" class="headerlink" title="周活跃用户"></a>周活跃用户</h3><p>WAU，Weekly Active User，指某个自然周内启动过应用的用户，该周内的多次启动只记一个活跃用户。这个指标是为了查看用户的类型结构，如轻度用户、中度用户、重度用户等</p><h3 id="用户保有率"><a href="#用户保有率" class="headerlink" title="用户保有率"></a>用户保有率</h3><p>用户保有率指再单位时间内符合有效用户条件的用户数再实际产生用户量的比率，也叫用户留存</p><script type="math/tex; mode=display">保有率=保有量/实际量</script><p>次日留存率：(当天新增的用户中，，在第二天还登陆的用户数) / 第一天新增总用户数。因为都是新用户，所以结合产品的新手引导设计和新用户转化路径来分析用户的流失原因，通过不断的修改和调整来降低用户流失，提升次日留存率，通常这个数字如果达到了40%就表示产品非常优秀了。<br>第3日留存率：(第一天新增用户中，在往后的第三天还有登录的用户数) / 第一天新增总用户数<br>周留存率：(第一天新增用户中，在往后7天还有登陆的用户数) / 第一天新增总用户数。在这个时间段里，用户通常会经历一个完整的使用和体验周期，如果在这个阶段用户能够留下来，就有可能成为忠诚度较高的用户。<br> 月留存率：（第一天新增的用户中，在往后的第 30 天还有登录的用户数） /第一天新增总用户数。通常移动 APP 的迭代周期为 2-4 周一个版本，所以月留存是能够反映出一个版本的用户留存情况，一个版本的更新，总是会或多或少的影响用户的体验，所以通过比较月留存率能够判断出每个版本更新是否对用户有影响。<br> 渠道留存：因为渠道来源不一，用户质量也会有差别，所以有必要针对渠道用户进行留存率分析。而且排除用户差别的因素以后，再去比较次日，周留存，可以更准确的判断产品上的问题。<br> 留存用户和留存率通常反映了不同时期获得的用户流失的情况，表现不同时期用户对产品的适应性和黏性，分析这个结果往往是为了找到用户流失的具体原因</p>]]></content>
      
      
      <categories>
          
          <category> 产品经理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品经理 </tag>
            
            <tag> 数据指标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2019/07/31/fastpower/"/>
      <url>/2019/07/31/fastpower/</url>
      
        <content type="html"><![CDATA[<h2 id="【介绍】"><a href="#【介绍】" class="headerlink" title="【介绍】"></a>【介绍】</h2><p>顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。</p><h2 id="【描述】"><a href="#【描述】" class="headerlink" title="【描述】"></a>【描述】</h2><p>计算a的n次方就是将n个a乘起来<script type="math/tex">a^n = \underbrace{a \times a \times a...\times a}_{\text{n个a}}</script>。但是，当n的值特别大的时候，这种累乘的方法就不合适了。不过，由结合律我们知道$a^b + a^c = a^{bc} , a^b \times a^b= a^{2b} = {a^b}^2$。二进制取幂的想法是，我们将取幂的任务按照指数的<strong>二进制表示</strong>来分割成更小的任务。我们来举个例子</p><blockquote><p>11的二进制数为 1011。 对进制不太理解的戳<a href>这里</a> </p></blockquote><script type="math/tex; mode=display">\begin{equation}3^{11} = 3^{1011} = 3^8 \cdot 3^2 \cdot 3^1\end{equation}</script><p>上面这个算式是怎么来的呢。看下面</p><script type="math/tex; mode=display">\begin{equation}3^1 = {3^2}^0 = 3 \\3^2 = {3^2}^1 = 9 \\3^8 = {3^2}^3 = 6561 \end{equation}</script><p>也就是为了计算<script type="math/tex">3^{11}</script>,我们只需要将二进制位对应为1的整系数幂乘起来就行了：</p><script type="math/tex; mode=display">\begin{equation}3^{11} = 3 \times 9 \times 6561 = 177147\end{equation}</script><p>将上述过程说的形式化一些，如果把n写作二进制为<script type="math/tex">(n_1n_{t-1}…n_12^1+n_02^0)</script>,那么有：</p><script type="math/tex; mode=display">\begin{equation}n=n_t2^t+n_{t-1}2^{t-1}+…+n_12^1+n_02^1\end{equation}</script><p>其中$n \epsilon 0,1$ 。那么就有</p><script type="math/tex; mode=display">\begin{equation}a^n=(a^{n_t2^t+…+n_02^0}) \\=a^{n_02^0} \times a^{n_12^1} \times … \times a^{n_02^0} \end{equation}</script><p>根据上式我们发现，原问题被我转换成了形式相同的子问题的乘积，并且我们可以在常数时间内从<script type="math/tex">2^i</script>项推出<script type="math/tex">2^{i+1}</script>项。这个算法的复杂度是<script type="math/tex">O(log_2n)</script>的。</p><h2 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power1</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = power(a,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((n%<span class="number">2</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="非递归式"><a href="#非递归式" class="headerlink" title="非递归式"></a>非递归式</h3><p>它在循环的过程将二进制为1时对应的幂累乘到答案中。尽管两者的理论复杂度相同，但第二种在实践过程中的速度会比递归式更快的，因为递归会重复运算花费一定开销。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power2</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                res*=a;</span><br><span class="line">            &#125;</span><br><span class="line">            a*=a;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL与图形界面安装------放弃虚拟机吧</title>
      <link href="/2019/07/30/wsl/"/>
      <url>/2019/07/30/wsl/</url>
      
        <content type="html"><![CDATA[<p>记录下在自己安装wsl的心(cai)路(坑)过程</p><h2 id="需要安装的插件"><a href="#需要安装的插件" class="headerlink" title="需要安装的插件"></a>需要安装的插件</h2><p><a href="https://sourceforge.net/projects/vcxsrv/" target="_blank" rel="noopener">VcXrc</a></p><p>参考<br>[1] <a href="https://www.linuxidc.com/Linux/2018-12/156031.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2018-12/156031.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> Linux </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序的单链表</title>
      <link href="/2019/07/27/mergelinkedlist/"/>
      <url>/2019/07/27/mergelinkedlist/</url>
      
        <content type="html"><![CDATA[<h1 id="合并两个有序的单链表"><a href="#合并两个有序的单链表" class="headerlink" title="合并两个有序的单链表"></a>合并两个有序的单链表</h1><h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>给定两个有序单链表head1和head2，请合并两个两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">7</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">7</span>-&gt;<span class="number">9</span>-&gt;<span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>合并后的链表为：0-&gt;1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;7-&gt;7-&gt;9 </p><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><ol><li>如果两个链表中有一个为空，说明无需合并过程，返回另一个链表头即可。</li><li>比较head1 和 head2 的值，小的节点也就是合并后链表的最小节点，这个节点就是合并后链表的头节点，我们记为head；在之后的步骤里，那个链表的头节点的值更小，另一个链表的所有节点都会依次插入到这个链表中。</li><li>我们让head1 和 head2 从头开始一起遍历，比较每次遍历到的两个节点的值，记为cur1和cur2，然后根据大小关系做出不同的调整，同时用一个变量pre表示上次比较较小的值。<br>4.如果其中一条链表走完，那就把另一条链表剩下的部分直接拼到最后，调整结束。</li><li>返回合并后链表的头节点head即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">merge</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果其中一条链表为空，直接返回另一条链表的头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1 !=<span class="keyword">null</span> ? head1 : head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将头节点较小的链表赋给head</span></span><br><span class="line">        Node head = head1.value &lt; head2.value ? head1 : head2;</span><br><span class="line">        <span class="comment">//较小链表的节点值</span></span><br><span class="line">        Node cur1 = head == head1 ? head1 : head2;</span><br><span class="line">        <span class="comment">//另一条链表的节点值</span></span><br><span class="line">        Node cur2 = head == head1 ? head2: head1;</span><br><span class="line">        <span class="comment">//保存上次比较时较小的值</span></span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//保存cur2的下个节点</span></span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果cur1&lt;cur2 将cur1往后移</span></span><br><span class="line">            <span class="keyword">if</span>(cur1.value &lt;= cur2.value)&#123;</span><br><span class="line">                pre = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果cur1&gt;cur2 将cur2插入到head链表</span></span><br><span class="line">                next = cur2.next;</span><br><span class="line">                pre.next = cur2;</span><br><span class="line">                cur2.next = cur1;</span><br><span class="line">                cur2 = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur1 == <span class="keyword">null</span> ? cur2: cur1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="/2019/07/25/pringmatrix/"/>
      <url>/2019/07/25/pringmatrix/</url>
      
        <content type="html"><![CDATA[<h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>给定一个矩阵matrix，请按照顺时针的方式打印它。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span></span><br><span class="line"><span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>打印结果为：1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>本体上算法没有难度，关键在于设计一种容易理解、代码易于实现的方式。我们可以采用矩阵分圈处理。在矩阵中用左上角的坐标(lx,ly)和右下角的坐标(rx,ry)就可以表示一个子矩阵。比如题目中的矩阵，当(lx,ly)=(0,0)、(rx,ry)=(3,3)时，表示的子矩阵就是整个矩阵，那么这个子矩阵的最外层的部分如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">5</span>           <span class="number">8</span></span><br><span class="line"><span class="number">9</span>           <span class="number">12</span></span><br><span class="line"><span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>我们可以先把矩阵的最外层打印出来，接下来令lx和ly加1，rx和ry减1，即(lx,ly)=(1,1)、(rx,ry)=(2,2),此时表示的子矩阵如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">10</span>  <span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>再把这个子矩阵转圈打印出来即可。如果发现左上角坐标跑到了右下角的右方或下方，整个过程结束。我们将每次打印的结果放到一个list数组里最后输出即可。(当然，你也可以选择每次循环时直接打印值)<br>具体过程参看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintMatrix</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rx = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ry = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ly &lt;= rx &amp;&amp; ly &lt;= ry) &#123;</span><br><span class="line">            printEdge(matrix, ly++, ly++, rx--, ry--);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子矩阵只有一行时</span></span><br><span class="line">        <span class="keyword">if</span> (lx == rx) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ly; i &lt;= ry; i++) &#123;</span><br><span class="line">                list.add(matrix[lx][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//子矩阵只有一列时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ly == ry) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; i++) &#123;</span><br><span class="line">                list.add(matrix[i][ly]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curC = ly;</span><br><span class="line">            <span class="keyword">int</span> curR = lx;</span><br><span class="line">            <span class="keyword">while</span> (curC != ry) &#123;</span><br><span class="line">                list.add(matrix[lx][curC]);</span><br><span class="line">                curC++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != rx) &#123;</span><br><span class="line">                list.add(matrix[curR][ry]);</span><br><span class="line">                curR++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC != ly) &#123;</span><br><span class="line">                list.add(matrix[rx][curC]);</span><br><span class="line">                curC--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != lx) &#123;</span><br><span class="line">                list.add(matrix[curR][ly]);</span><br><span class="line">                curR--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O 总结</title>
      <link href="/2019/07/25/javaio/"/>
      <url>/2019/07/25/javaio/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Java-I-O流"><a href="#Java-I-O流" class="headerlink" title="Java I/O流"></a>Java I/O流</h1><p><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/JavaIO.png?raw=true"></p><h2 id="一、-Java-IO-原理"><a href="#一、-Java-IO-原理" class="headerlink" title="一、 Java IO 原理"></a>一、 Java IO 原理</h2><ul><li>输入 input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。</li><li>输出 output：将程序(内存)数据输出到磁盘、光盘等存储设备中。</li></ul><h2 id="二、-流的分类"><a href="#二、-流的分类" class="headerlink" title="二、 流的分类"></a>二、 流的分类</h2><ul><li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li><li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li><li>按流的<strong>角色</strong>的不同分为：节点流，处理流</li></ul><div class="table-container"><table><thead><tr><th>[抽象基类]</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputSreeam</td><td>Writer</td></tr></tbody></table></div><p>Java的IO流共设计40多个类，实际上非常规则，都是从以上4个抽象基类派生的。</p><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 </p><p><strong>InputStream 和 Reader 是所有输入流的基类</strong></p><h3 id="2-1-InputStream-典型实现：FileInpugStream"><a href="#2-1-InputStream-典型实现：FileInpugStream" class="headerlink" title="2.1 InputStream (典型实现：FileInpugStream)"></a>2.1 InputStream (典型实现：<strong>FileInpugStream</strong>)</h3><ul><li>int read()<br>在输入流中读取数据的下一个字节。返回0-255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回-1.</li><li><strong>int read(byte[])</strong><br>从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值为-1。否则<strong>以整数形式返回时机读取的字节数</strong> </li><li>int read(byte[],int off,int len)<br>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值为-1.   </li><li>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader。</li></ul><h3 id="2-2-Reader-典型实现：FileReader"><a href="#2-2-Reader-典型实现：FileReader" class="headerlink" title="2.2 Reader (典型实现：FileReader)"></a>2.2 Reader (典型实现：<strong>FileReader</strong>)</h3><ul><li>int read()<br>读取单个字符。作为整数读取的字符，范围在0-65535之间(0x00-0xffff)(2个字节的Unicode码),如果已到达流的末尾，则返回-1</li><li><strong>int read(char[] c)</strong><br>将字符读入数组。如果已到达流的末尾，则返回-1.否则返回本次读取的字符数</li><li>int read(char[] c,int off,int len)<br>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则饭hi本次读取的字符数。</li></ul><p><strong>OutputStream和Writer 是所有输出流的基类</strong></p><h3 id="2-3-OutPutStream"><a href="#2-3-OutPutStream" class="headerlink" title="2.3 OutPutStream"></a>2.3 OutPutStream</h3><ul><li>void write(int b)<br>将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。即写入0~255范围的。</li><li>void write(byte[] b)<br>将 b.length 个字节从指定的 byte 数组写入此输出流。write(b)的常规协定是：应该 与调用 write(b, 0, b.length) 的效果完全相同。</li><li>void write(byte[] b,int off,int len)<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 </li></ul><h3 id="2-4-Writer"><a href="#2-4-Writer" class="headerlink" title="2.4 Writer"></a>2.4 Writer</h3><ul><li>void write(int c)<br>写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。即 写入0 到 65535 之间的Unicode码。<ul><li>void write(char[] cbuf)<br>写入字符数组。</li><li>void write(char[] cbuf,int off,int len)<br>写入字符数组的某一部分。从off开始，写入len个字符</li><li>void write(String str)<br>写入字符串。</li><li>void write(String str,int off,int len)<br>写入字符串的某一部分。</li><li>void flush()<br>刷新该流的缓冲，则立即将它们写入预期目标。 </li></ul></li></ul><p>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件IO资源</strong></p><h2 id="三、节点流-或文件流"><a href="#三、节点流-或文件流" class="headerlink" title="三、节点流(或文件流)"></a>三、节点流(或文件流)</h2><p>直接从数据源或目的地读写数据</p><h4 id="3-1读取文件"><a href="#3-1读取文件" class="headerlink" title="3.1读取文件"></a>3.1读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.建立一个流对象，将已存在的一个我呢见加载进流</span></span><br><span class="line">FiileReader fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建有一个临时存放数据的数组</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用流对象的读取方法将流中的数据读入到数组中。</span></span><br><span class="line">fr.read(ch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>]; </span><br><span class="line">    <span class="keyword">int</span> len; </span><br><span class="line">    <span class="keyword">while</span> ((len = fr.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">    System.out.println(<span class="string">"read-Exception :"</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            fr.close(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            System.out.println(<span class="string">"close-Exception :"</span> + e.getMessage();       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">#### 3.2 写入文件</span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建流对象，建立数据存放文件</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用流对象的写入方法，将数据写入流</span></span><br><span class="line">fw.write(<span class="string">"I hava a dream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流资源</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fw = <span class="keyword">new</span> FileWrtier(<span class="keyword">new</span> File(<span class="string">"Test.txt"</span>));</span><br><span class="line">    fw.write(<span class="string">"I hava a dream"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fw != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><ul><li>定义文件路径时，注意：可以用“/”或者“\”</li><li>在<strong>写入</strong>一个文件时，如果使用构造器FileOutputStream(file),则<strong>目录下有同名文件将被覆盖</strong></li><li>如果使用构造器FileOutputStream(file,true),则目录下的同迷宫文件不会被覆盖，<strong>在文件内容末尾追加内容</strong></li><li>在<strong>读取</strong>文件时，必须保证该文件已存在，否则报异常</li><li>字节流操作字节，比如：.mp3、.avi、.mp4、.jpg、.doc等</li><li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：txt、java、c、cpp等语言的额源代码。尤其注意doc、excel、ppt这些不是文本文件</li></ul><h2 id="四、处理流"><a href="#四、处理流" class="headerlink" title="四、处理流"></a>四、处理流</h2><p>不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序 提供更为强大的读写功能。</p><h3 id="4-1-缓冲流-处理流之一"><a href="#4-1-缓冲流-处理流之一" class="headerlink" title="4.1 缓冲流(处理流之一)"></a>4.1 缓冲流(处理流之一)</h3><ul><li><strong>为了提高数据读写的速度</strong>，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用 ==8192个字节(8kb)的缓冲区==</li></ul><p><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/buffer.png?raw=true" alt="buffer"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line">```  </span><br><span class="line">- 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为</span><br><span class="line">    - BufferedInputStream 和 BufferedOutputStream</span><br><span class="line">    - BufferedReader 和 BufferedWriter</span><br><span class="line">- 当读取数据时，数据按块读入缓冲区，其后的读操作直接访问缓冲区</span><br><span class="line">- 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件读取<span class="number">8192</span>(<span class="number">8</span>kb),存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个<span class="number">8192</span>个字节数组。</span><br><span class="line">- 向流中写入字节时，不会直接写道文件，先写道缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法**flush()**可以强制将缓冲区的内容全部写入输入流</span><br><span class="line">- 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外城流也会相应关闭内层节点流</span><br><span class="line">- flush()方法的使用：手动将buffer中内容写入文件</span><br><span class="line">- 如果是带缓冲区的流对象close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭不能再写出</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建缓冲流对象：它是处理流，是对节点流的包装</span></span><br><span class="line">      br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"d:\\IOTest\\source.txt"</span>)); </span><br><span class="line">      bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\IOTest\\d est.txt"</span>));</span><br><span class="line">      String str;</span><br><span class="line">      <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 一次读取字符文本文件的一行字符</span></span><br><span class="line">        bw.write(str); <span class="comment">// 一次写入一行字符串</span></span><br><span class="line">        bw.newLine(); <span class="comment">// 写入行分隔符</span></span><br><span class="line">      &#125; </span><br><span class="line">      bw.flush(); <span class="comment">// 刷新缓冲区</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭IO流对象</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">               bw.close(); <span class="comment">// 关闭过滤流时,会自动关闭它所包装的底层节点流</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123; </span><br><span class="line">               br.close();</span><br><span class="line">           &#125; </span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-转换流-处理流之二）"><a href="#4-2-转换流-处理流之二）" class="headerlink" title="4.2 转换流(处理流之二）"></a>4.2 转换流(处理流之二）</h3><p>转换流提供了字节流和字符流之间的转换<br><img src="https://github.com/SGEEKioi/Review/blob/master/imgs/%E8%BD%AC%E6%8D%A2%E6%B5%81.png?raw=true" alt="zhuanhuan"><br>Java API提供了两个转换流：</p><pre><code>- InputStreamReader：将InputStream转换为Reader    **实现将字节的的输入流按指定字符集转换为字符的输入流。**    - 需要和InputStream“套接”    - 构造器        - public InputStreamReader(InputStream in)        - public InputStreamReader(InputStream in,String charsetName)- OutputStreamWriter：将Writer转换为OutputStream    **实现将字符的输出流按指定字符集转换为字节的输出流**    - 需要和OutputStream“套接”    - 构造器        - public OutputStreamWriter(OutputStream out)        - public OutputStreamWriter(OutputStream out,String charsetName)</code></pre><ul><li>字节流中的数据都是字符时，转成字符流操作更高效。</li><li>很多时候我们使用转换流来处理文件乱码问题。实现编码和节码的功能。</li></ul><h3 id="4-3-打印流-标准流之三）"><a href="#4-3-打印流-标准流之三）" class="headerlink" title="4.3 打印流(标准流之三）"></a>4.3 打印流(标准流之三）</h3><p>实现将<strong>基本数据类型</strong>的数据格式转换为<strong>字符串</strong><br>打印流：PrintStream和PrintWriter</p><ul><li>提供了一系列重载的print()和pringln()方法，用于多种数据类型的输出</li><li>PrintStream和PrintWriter的输出不会抛出IOException异常</li><li>PrintStream和PrintWriter有自动flush功能</li><li>PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应使用PrintWriter类。</li><li>System.out返回的是PrintStream的实例</li></ul><h3 id="4-4-对象流"><a href="#4-4-对象流" class="headerlink" title="4.4 对象流"></a>4.4 对象流</h3><p>ObjectInputStream和ObjectOutputStream</p><ul><li><p>用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p></li><li><p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p></li><li><p>反序列化：用ObjectInputStream类<strong>读取</strong>基本数据类型或对象的机制</p></li><li><p>ObjectOutStream和ObjectInputStream不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</p></li></ul><h3 id="4-5对象的序列化"><a href="#4-5对象的序列化" class="headerlink" title="4.5对象的序列化"></a>4.5对象的序列化</h3><ul><li><strong>对象的序列化机制</strong>允许把内存中的Java对象转化称平台无关的二进制流，从而把允许这种二进制流持久的保存在磁盘上，或通过网络将这中二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象</li><li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li><li>序列化时RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li><li>如果需要让两个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，则该类必须实现如下两个接口之一<ul><li><strong>Serializable</strong></li><li>Externlizable</li></ul></li><li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul><li>private static final long serialVersionUID;</li><li>serialVersionUID 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li><li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。<strong>若类的实例变量做了修改，serialVersionUID可能发生变化。</strong>故建议，显示声明。</li></ul></li><li>简单来说，Java的序列化机制是通过在运行是判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidcastException)</li></ul><h5 id="4-5-1-使用对象流序列化对象"><a href="#4-5-1-使用对象流序列化对象" class="headerlink" title="4.5.1 使用对象流序列化对象"></a>4.5.1 使用对象流序列化对象</h5><ul><li>若某个类实现了Serializable接口，该类的对象就是可序列化的：<ul><li>创建一个ObjectOututStream</li><li>调用ObjectoutputStream对象的writeObject(对象)方法输出可序列化对象</li><li>注意写一次，操作一次flush()</li></ul></li><li>反序列化<ul><li>创建一个ObjectInputStream</li><li>调用readObject()方法读取流中的对象<blockquote><p>如果某个类的属性不是基本数据类型或String类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类也不能序列化   </p></blockquote></li></ul></li></ul><p>序列化：将对象写入到磁盘或者进行网络传输。要求对象必须实现序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">Persion p = <span class="keyword">new</span> Per(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="string">"北京"</span>,<span class="keyword">new</span> Pet());</span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">反序列化：将磁盘中的对象数据源读出。</span><br><span class="line">```java</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">Persion p1 = (Persion)ois.readObject();</span><br><span class="line">System.out.println(p1.toString());</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></p><blockquote><p>面试题<br>**谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其他人是吗？</p><ul><li>实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。<strong>这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异</strong>。换句话说，可以在Windows机器上创建一个对象，对其序列化 ，然后通过网络发给一台Unix机器，然后在那里准确无误地重新装配。不必关心数据在不同机器上如何表示，也不必关心字节地顺序或者其他任何细节。</li><li>由于大部分作为参数地类如String、Integer等都实现了Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</li></ul></blockquote><h4 id="4-5-2随机存取文件流-RadnomAccessFile类"><a href="#4-5-2随机存取文件流-RadnomAccessFile类" class="headerlink" title="4.5.2随机存取文件流 RadnomAccessFile类"></a>4.5.2随机存取文件流 RadnomAccessFile类</h4><p>我们可以用RandomAccessFile这个类，来实现一个<strong>多线程断点下载</strong>的功能，用过下载工具的朋友们都知道，下载前都会建立<strong>两个临时文件</strong>，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上次的地方下载，从而是按断点下载或上传的功能。</p><ul><li>读取文件内容<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(“test.txt”, “rw”);</span><br><span class="line">raf.seek(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">byte</span> [] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">5</span>;</span><br><span class="line">raf.read(b, off, len);</span><br><span class="line">String str = <span class="keyword">new</span> String(b, <span class="number">0</span>, len); System.out.println(str);</span><br><span class="line">raf.close();</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">- 写入文件内容</span><br><span class="line">```java</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>, <span class="string">"rw"</span>); raf.seek(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//先读出来 String temp = raf.readLine();</span></span><br><span class="line">raf.seek(<span class="number">5</span>); raf.write(<span class="string">"xyz"</span>.getBytes()); </span><br><span class="line">raf.write(temp.getBytes());</span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计一个有getMin功能的栈</title>
      <link href="/2019/07/23/getMinStack/"/>
      <url>/2019/07/23/getMinStack/</url>
      
        <content type="html"><![CDATA[<h1 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h1><h2 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h2><p>实现一个特殊的栈，在实现栈的基本功能的基础上，在实现返回栈中最小元素的操作</p><h2 id="【要求】"><a href="#【要求】" class="headerlink" title="【要求】"></a>【要求】</h2><ol><li>pop、push、getMin操作的时间复杂度都是O(1).</li><li>设计的站的类型可以使用现成的栈结构。</li></ol><h2 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h2><p>在设计时，我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData；另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体实现方式有两种。</p><h3 id="第一种设计方案"><a href="#第一种设计方案" class="headerlink" title="第一种设计方案"></a>第一种设计方案</h3><ol><li>压入规则<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空：<ul><li>如果为空，则newNum也压入stackMin。</li><li>如果不为空，则比较newNum和stackMin栈顶元素哪一个更小：<ul><li>如果newNum更小或者两者相同，则newNum也压入stackMin；</li><li>如果stackMin中栈顶元素小，则stackMin不压入任何元素；</li></ul></li></ul></li><li>弹出规则</li></ol><ul><li>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪个更小。</li><li>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素，返回value；</li></ul><ol><li>查询当前栈中的最小值<br>通过上文我们知道stackMin的栈顶元素一直记录着stackData的最小值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinStack1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetMinStack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二种设计方案"><a href="#第二种设计方案" class="headerlink" title="第二种设计方案"></a>第二种设计方案</h3><ol><li>压入规则</li></ol><ul><li>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<ul><li>如果为空，则newNum也压入stackMin；</li><li>如果不为空，则比较newNum和stackMin的栈顶元素哪一个更小。<ul><li>如果newNum更小或相等，则newNum压入stackMin；</li><li>如果stackMin中栈顶元素小，则把stackMin的栈顶元素重复压入stackMin中。</li></ul></li></ul></li></ul><ol><li>弹出规则<br>在stackData中弹出数据，弹出的数据记为value；弹出stackMin的栈顶元素，返回value。</li><li>查询当前栈中最小值<br>由上文的规则可知，stackMin栈顶元素始终记录着stackData中的最小值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMinStack2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetMinStack2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackMin.isEmpty()) &#123;</span><br><span class="line">            stackMin.push(newNum);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum &lt;= <span class="keyword">this</span>.getMin())&#123;</span><br><span class="line">            stackMin.push(newNum);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newMin = stackMin.peek();</span><br><span class="line">            stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackData.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="【点评】"><a href="#【点评】" class="headerlink" title="【点评】"></a>【点评】</h2><p>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点时所有操作的时间复杂度都为O(1)、空间复杂度都为O(n)。区别是：方案一种stackMin压入稍省时间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础——自增变量</title>
      <link href="/2019/07/22/selfadd/"/>
      <url>/2019/07/22/selfadd/</url>
      
        <content type="html"><![CDATA[<h2 id="自增-：将变量的值加-1"><a href="#自增-：将变量的值加-1" class="headerlink" title="自增 (++) ：将变量的值加 1"></a>自增 (++) ：将变量的值加 1</h2><ol><li>前缀式：如 ++i。前缀式是先加1再使用。</li><li>后缀式：如 i++。后缀式是先使用再加1。</li></ol><h2 id="自减-—-将变量的值减-1"><a href="#自减-—-将变量的值减-1" class="headerlink" title="自减 (—) : 将变量的值减 1"></a>自减 (—) : 将变量的值减 1</h2><ol><li>前缀式：如 —i。前缀式是先减1再使用。</li><li>后缀式：如 i—。后缀式是先使用再减1。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面我们来看一个例题，如果你能很轻易的算出结果，估计本文对你帮助不太大了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">       i = i++;</span><br><span class="line">       <span class="keyword">int</span> j = i++;</span><br><span class="line">       <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">       System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">       System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i = 4</span><br><span class="line">j = 1</span><br><span class="line">k = 11</span><br></pre></td></tr></table></figure></p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>我们来分析一下运算过程<br><img src="/2019/07/22/selfadd/selfadd.jpg" alt="add"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>赋值 = ，最后计算</li><li>=右边的从左到右加载值依次<strong>压入操作数栈</strong></li><li>实际先算哪个，看运算符优先级</li><li>自增、自减操作都是直接修改便俩个的值，不经过操作数栈</li><li>最后的赋值之前，临时结果也是存储在操作数栈中</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 自增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(四)类文件结构</title>
      <link href="/2019/07/18/JVM4/"/>
      <url>/2019/07/18/JVM4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在Java中，JVM可以理解的代码叫做==字节码==(及 .class文件)。Java语言通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效。</p><h2 id="Class文件结构总结"><a href="#Class文件结构总结" class="headerlink" title="Class文件结构总结"></a>Class文件结构总结</h2><p>Class文件是一组以8位字节为基础单位的二进制流。Class文件格式采用一种类似与C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、两个字节、4个字节和8个字节的无符号数，无符号数 可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯地以“_info”结尾。整个Class文件本质上就是一张表，它由一下所示地数据项构成。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>1 </td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods</td><td>methods_count</td></tr><tr><td>methods_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table></div><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个Class文件的头四个字节称为魔数(Magic Nuber),它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4      magic; <span class="comment">//Class文件的标志</span></span><br></pre></td></tr></table></figure></p><h3 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h3><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5个和第6个字节是次版本号(Mainor Version),第7和第8个字节是主版本号(Major Version).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2      minor_version;<span class="comment">//Class的次版本号</span></span><br><span class="line">u2      major_sersion;<span class="comment">//Class的主版本号</span></span><br></pre></td></tr></table></figure></p><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主次版本号之后的是常量池，常量池的数量是constant_pool_count-1（常量池计数器是从1开始计数的，<strong>索引为0代表不引用任何一个常量池项</strong>)<br>常量池主要存放两大类长量：字面量和符号引用。字面量比较接近于Java与语言层面的常量的概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符<br>常量池中每一项常量都是一个表，这14中表有一个共同特点：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量术语那种类型常量。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td><td>表示有一个动态方法调用点</td></tr></tbody></table></div><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束后，紧接着的两个字节代表访问标志(access_flags),这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。<br>类访问和属性修饰符：<br>标志名称 | 标志值 | 含义<br>— | — | —<br>ACC_PUBLIC | 0x0001 | 是否为public类型<br>ACC_FINAL | 0x0010 | 是否被声明为final，只有类可设置<br>ACC_SUPER | 0x0020 | 是否允许使用invokespecial字节码指令的新语意<br>ACC_INTERFACE | 0x200 | 标志这是一个接口<br>ACC_ABSTRACT | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类值为假<br>ACC_SYNTHETIC | 0x1000 | 标识这个类并非由用户代码产生的<br>ACC_ANOTATION | 0x2000 | 标识这是一个注释<br>ACC_ENUM | 0x4000 | 标识这是一个枚举</p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个雷可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多继承，索引父类索引只有一个，除了==java.lang.Object==之外，所有的Java类都有父类，因此除了==java.lang.Object==外。</p><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按==implements==语句(如果这个类本身是一个接口，则应当是extends)后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表(field info) 用于描述接口或类中声明的标量。字段保罗类级别变量以及实例变量，但不包括在方法内部声明的局部变量。<br>字段表结构：</p><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>作用</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td><td>字段的作用域，是实例变量还是类变量(static修饰符)，可否被序列化(transient修饰符),可变性(final)，可见性(volatile)</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>对常量池的引用，表示的字段的名称</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td><td>对常量池的引用，表示字段和方法的描述</td></tr><tr><td>u2</td><td>attributes</td><td>1</td><td>存放具体属性内容</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>一个字段还会拥有一些额外的属性，用来存放属性的个数</td></tr></tbody></table></div><p>字段的access_flags的取值</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private </td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否pritected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FIANL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生的</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table></div><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p>Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>数量 </th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1 </td></tr><tr><td>u2</td><td>name_index</td><td>1 </td></tr><tr><td>u2</td><td>descriptor_index</td><td>1 </td></tr><tr><td>u2</td><td>attributes</td><td>1 </td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table></div><p>方法的access_flags的取值</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否private </td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否pritected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FIANL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器自动产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x1000</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x4000</td><td>方法是否为Abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x8000</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生的</td></tr></tbody></table></div><p>方法里的Java代码，经过编译器编译称字节码指令后，存放在方法属性中一个名为“code”的属性里面。</p><h3 id="属性标集合"><a href="#属性标集合" class="headerlink" title="属性标集合"></a>属性标集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在Class文件、字段表、方法表、都可以携带字节的属性表集合，以用于描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了些，不再要求各个属性具有严格的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以像属性表中写入自己定义的属性信息。Java虚拟机运行时会忽略掉他不认识的属性。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(三)虚拟机性能监控与故障处理工具</title>
      <link href="/2019/07/18/JVM3/"/>
      <url>/2019/07/18/JVM3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h2><p>这些命令在JDK安装目录的bin目录下<br>名称 | 主要作用<br>—   | — |<br>jps  | JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程<br>jstat | JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据<br>jinfo | Configuration Info for Java，显示虚拟机配置信息<br>jmap | Memory Map for Java，生成虚拟机的内存转储快照<br>jhat | JVM Heap Dump Browser,用于分析heapdump文件，他会建立一个HTTP/HTML服务器，让用户可以i在浏览器查看分析结果<br>jstack | Stack Trace for Java，显示虚拟机的线程快照</p><h3 id="jps-查看所有Java进程"><a href="#jps-查看所有Java进程" class="headerlink" title="jps:查看所有Java进程"></a>jps:查看所有Java进程</h3><p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID(LVMID)</p><h4 id="jps命令格式"><a href="#jps命令格式" class="headerlink" title="jps命令格式"></a>jps命令格式</h4><p>jps [options] [hostid]</p><p>jps工具主要选项<br>选项    |   作用<br>—  |   —<br>-q  |   只输出LVMID，省略主类的名称<br>-m  |   输出虚拟机 进程启动时传递给主类main()函数的参数<br>-1  |   输出主类的全名，如果进程执行的是jar包，输出jar包路径<br>-v  |   输出虚拟机进程启动时JVM参数</p><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>用于监视虚拟机各种运行状态信息的命令工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><h4 id="jstat命令格式"><a href="#jstat命令格式" class="headerlink" title="jstat命令格式"></a>jstat命令格式</h4><p>jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]] </count></interval></vmid></lines></option></p><div class="table-container"><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类加载所消耗的时间</td></tr><tr><td>-gc</td><td>监视Java堆状态，包括Eden区、两个Survivor、老年代、永久代等的容量、已用空间、GC时间合计等信息。</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC情况</td></tr><tr><td>-gcnewcapcity</td><td>监视内容与-gcnew基本相同，但主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代GC状态</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，输出主要关注使用到的额最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-complier</td><td>输出JIT编译器编译过的方法，耗时信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table></div><h3 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h3><p>实时查看和调整虚拟机各项参数</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>jinfo [option] pid</p><ul><li>jinfo -vmid:输出对应名称的参数的具体值。比如输出MaxHeapSize、查看当前jvm进程是否开启打印GC日志。</li><li>jinfo -flag [+ | -]name vimd 开启或者关闭对应的名称的参数<br>使用此命令可以在不开启虚拟机的情况下，可以动态的修改jvm的参数。尤其是线上的环境特别有用。</li></ul><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>用于生成堆转储块照。如果不使用jmap命令，要想获取Java堆转储快照，还可以使用“-XX：HeapDumpOnOutOfMemoryErroy”参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，Linux命令可以通过“kill -3”发送进程退出信号也能拿到dump文件。<br>jmap的作用不仅仅是为了获取dump文件，它还可以查询finalizer执行队列、Java堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。</p><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>与jmap搭配使用，来分析jmap生成的堆转储快照。它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。</p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><h4 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h4><p>jstack [option] vmid<br>option 选项<br>选项 | 作用<br>— | —<br>-F | 当输出的请求不被响应时，强制输出线程堆<br>-l | 除堆栈外，显示关于锁的附加信息<br>-m | 如果调用到本地方法的话，可以显示C/C++的堆栈</p><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>是一种基于JMX的可视化监视、管理工具。可以很方便的监视本地及远程服务器的java进程的内存使用情况。你可以在控制台输出console命令启动或者在JDK目录下的bin目录找到jconsole.exe启动。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(二)垃圾收集器与内存分配策略</title>
      <link href="/2019/07/18/JVM2/"/>
      <url>/2019/07/18/JVM2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>人们早期就在思考GC需要完成的3件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><blockquote><p>当我们需要排查各种内存溢出、内存泄漏问题时、当垃圾收集成为系统达到更高并发量的瓶颈时，，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p></blockquote><h3 id="1-JVM内存分配与回收"><a href="#1-JVM内存分配与回收" class="headerlink" title="1. JVM内存分配与回收"></a>1. JVM内存分配与回收</h3><p>Java的自动你内存管理主要时针对对象内存的回收和对象内存的分配。同时，Java内存管理最核心的功能时<strong>堆</strong>内存中对象的分配与回收。</p><p>Java堆是垃圾回收器管理的主要区域，因此也被称为<strong>GC堆</strong>。从垃圾回收的角度，由于现在收集器基本采用分代垃圾收集算法，所以Java 堆海口可以细分为：新生代和老年代；再细致一点有：Eden空间、From Surivior、To Survior空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存</strong>。</p><h4 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h4><p><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%A0%86%E7%A9%BA%E9%97%B4.jpg?raw=true" alt="堆空间"></p><ul><li>新生代：eden区、s0(From)区、s1(To)</li><li>老年代: tentired区</li></ul><p>大部分情况，对象都会首先再eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s1,并且对象的年龄还会加1(eden区-&gt;Surrvior区后对象的初始年龄变为1)，当它的年龄增加到一定程度(默认15),就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 ==-XX:MaxTenuringThreshold== 来设置。经过这次GC后，eden区和“From”区已经被清空。这个时候“From”和“To”会交换他们的角色，就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor FC会一直重复这样的过程，直到”To”区被填满之后，会将所有对象移动到老年代中。</p><h4 id="堆内存常见分配策略"><a href="#堆内存常见分配策略" class="headerlink" title="堆内存常见分配策略"></a>堆内存常见分配策略</h4><ul><li>对象优先在eden区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li></ul><h5 id="对象优先在eden区分配"><a href="#对象优先在eden区分配" class="headerlink" title="对象优先在eden区分配"></a>对象优先在eden区分配</h5><p>目前主流的垃圾回收器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>Minor GC和Full GC的区别</strong></p><ul><li>新生代 GC(Minor GC): 指发生新生代的垃圾回收收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li>老年代 GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC(并非绝对),Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一下方式运行：<br><img src="https://camo.githubusercontent.com/2713b77464413e9aeb63cdd9d8cd198cb3fea34a/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32353137383335302e6a7067" alt="run"></p><p>添加参数：==-XX:+PrintGCDetails==</p><p><img src="https://camo.githubusercontent.com/9c349ba9ea4778b4c5f7cd0fb7e7efd812902330/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f31303331373134362e6a7067" alt="run"></p><p>运行结果：</p><p><img src="https://camo.githubusercontent.com/42464b598a233d4319009cc06e3d199b6331c314/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383935343238362e6a7067" alt="run"></p><p>从上图我们剋看出eden区内存几乎已经被分配完全(即使程序什么也不做，新生代也会使用20000多k内存)。假如我们再为allocation2分配内存会出现什么情况呢？</p><p><img src="https://camo.githubusercontent.com/215514817e1b01cd89ba942c382d2f64cb6c9e3d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32362f32383132383738352e6a7067" alt="run"></p><p><strong>解释一下为什么会出现这种情况</strong>：因为给allcation2分配内存的时候eden区内存几乎被分配完了，我们刚刚讲了eden区没有足够空间进行分配时，虚拟机将放弃一次Minor GC。GC 期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能狗仔eden区的话，还是会在eden区分配内存。</p><blockquote><p>空间分配担保<br>在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC 可以确保是安全地。</p></blockquote><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>所谓大对象是指需要大量连续内存空间的Java对象，如数组、字符串。<br>这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制(新生代采用复制算法收集内存)而降低效率。</p><h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>既然虚拟机才有用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。</p><p>如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并且能被Survivor容纳的话，将被移动Survivor空间中，并将对象年龄设为1。对象在Survivor区没每熬过一次Minor GC ，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁)，就会将被晋身到老年代中。对象晋升老年代的年龄阈值，可以通过参数==-XX:MaxTenuringThreshold== 设置</p><h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><p>为了能更好的使用不同程序的内存状态，虚拟机并不是永远地要求年龄必须达到MaxTenuringThreshold才能晋升为老年代，如果在Survivor空间相同年龄所有对象地总和大于Survivor空间地一半，年龄大于或等于该年龄地对象就可以直接进入老年代，无需等到要求年龄。</p><h4 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h4><p>堆中几乎存放着所有对象地实例，对垃圾回收前地第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用地对象)</p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对昂中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p><strong>这个算法实现简单，判定效率高，在大部分情况下他都是一个不错的算法。但是目前主流的虚拟机并没有选择这个算法来管理内存，其最主要的原因时它很难解决对象之间相互循环引用的问题。</strong></p><blockquote><p>举个例子:对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA,除此之外，这两个对象再无任何的引用，实际上这两个对象已经不可能在被访问，但是他们也因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ReferenceCountingGC ogjA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC ogjB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，则证明对象不可用。<br><img src="https://camo.githubusercontent.com/6c6a9c7e2a7849cab8d5966ec1916115380e2842/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f37323736323034392e6a7067" alt="keda"></p><h5 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h5><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。JDK1.2以后，Java对引用概念呢进行了扩充，将引用分为<strong>强引用、软引用、弱引用、虚引用</strong>(引用强度逐渐减弱)</p><h6 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h6><p>指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><h6 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h6><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><h5 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h5><p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联对象。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存周期构成影响，也无法通过虚引用来取得一个对象实例。唯一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><blockquote><p>在程序设计中一般很少使用弱引用和虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，放置内存溢出等问题的产生。</strong></p></blockquote><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，<strong>至少要经历两次标记过程</strong>：如果对象在进行可达分析后发现没有与GC Roots 相连接的引用链，那它将会被第一次标记且进行一次筛选，筛选条件是此对此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都是为“没有必要执行”。</p><p>被判定为需要执行的对象将会放置在一个叫做F-Queue的队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li>标记-清除算法</li><li>复制算法</li><li>标记算法</li><li>分代收集算法</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>该算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它主要不足有两个：</p><ol><li>效率问题：标记和清除两个过程的效率都不高</li><li>空间问题：标记清除后会产生大量不连续的内存碎片。<br><img src="https://camo.githubusercontent.com/dc1f798e7c7f9aa9a3ab692db10a6b1788e5d505/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f36333730373238312e6a7067" alt="baioji"></li></ol><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题,“复制”收集算法出现了，它将可用内存按照容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收。<br><img src="https://camo.githubusercontent.com/94cfc5e1fbe9d49b3ed056d2943fd86dac1833a2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39303938343632342e6a7067" alt="copy"></p><p>目前主流的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象要一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的地Survivor空间 (HotSpot虚拟机默认Eden和Survivor地大小比例是8：1);</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代地特点推出地一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以为的内存。</p><p><img src="https://camo.githubusercontent.com/e5223ec7b2460498e1934c14eeaf969bafdcab59/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f39343035373034392e6a7067" alt="bz"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集。这种算法没有什么新的思想，只是根据对象存活周期将内存分为几块。一般将Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点采用最适当的收集算法了。<strong>在新生代中，每次垃圾收集时都发现那个有大批量对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</strong></p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实。</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial(串行)收集器是最基本、历史最悠久的垃圾收集器。是一个<strong>单线程</strong>收集器。它的单线程意义不仅仅以为着它只会使用一条垃圾收集线程完成垃圾收集工作，更重要的是它在进行垃圾收集器工作的时候必须暂停其他所有的工作线程(“Stop The World”)，直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong><br><img src="https://camo.githubusercontent.com/aba41c5c08ea9884554b9a69ea69c7ceeebc83ff/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f34363837333032362e6a7067" alt="ser"></p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Servial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、huishoucelue)和Serial收集器完全一样。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong><br><img src="https://camo.githubusercontent.com/f298ba56ec4667487fdf4acc987f2ef9e6df254e/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f32323031383336382e6a7067" alt="par"></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有他能与CMS收集器(真正意义上的并发收集器)配合工作。</p><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>Parallel Scavenge 收集器也是四好用复制算法的多线程收集器，它看上去几乎和ParNew都以一样。那它有什么特别之处呢？</p><p>Parallel Scavenge 收集器 关注点是吞吐量(高效率的利用给CPU).CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间(提升用户体验)。</p><blockquote><p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p></blockquote><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量</p><ol><li>-XX:MaxGCPauseMillis<br> 控制最大垃圾收集停顿时间</li><li>-XX:GCTimeRatio<br> 直接设置吞吐量大小</li></ol><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。使用标记-整理算法。这个收集器的主要意义也是在于Client模式下的虚拟机使用。</p><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><p>Parallel Scavenge 收集器的老年代版本。使用多线程和标记整理算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge和parallel Old 收集器。</p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>CMS收集器是一种获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现，它的运作过程相对于前面几种收集器来说更复杂一些，分为4个步骤：</p><ul><li>初始标记：仅仅之际标记一下GC Roots能直接关联到的对象，速度很快；</li><li>并发标记：进行GC Roots Tracing的过程。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</li><li>并发清除：开启用户线程，同时GC 线程开始对为标记的区域进行清扫。</li></ul><p><img src="https://camo.githubusercontent.com/d74545af0f987d17b7f41a60bb237a113fff925b/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32372f38323832353037392e6a7067" alt="cms"></p><p>CMS收集器主要优点：并发收集、低停顿。但是它有一下3个明显的缺点：</p><ul><li>对CPU 资源非常敏感；</li><li>无法处理浮动垃圾；</li><li>使用标记-清除算法 导致收集结束时会有大量空间碎片产生。</li></ul><h5 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h5><p>G1 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以及高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。它具备以下特点：</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU(或者CPU核心)来缩短Stop-The-World停顿的时间，</li><li>分代收集：分代概念在G1收集器中得以保留，虽然G1可以不需要其他收集器配合就能独立管理整个GC堆。</li><li>空间整合：与CMS的标记-情理算法不同，G1从整体来看是基于标记整理算法实现的收集器，从局部来看是基于复制算法实现的。</li><li>可预测的停顿：这是G1相对与CMS的另一个大优势，降低停顿时间G1和CMS共同的关注点，但G1除了追求停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间段内。</li></ul><p>G1收集器的运作分为一下一个步骤</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的手机效率(把内存化整为零)。</p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(五)虚拟机类加载机制</title>
      <link href="/2019/07/18/JVM5/"/>
      <url>/2019/07/18/JVM5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称连接。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg?raw=true" alt="leijiazai"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，但是解析阶段不一定：它再某些情况下可以再初始化阶段之后再开始。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段需要完成3件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。</li></ol><p><strong>一个非数组类的加载阶段(加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，可以通过定义自己的类加载器去控制字节流的获取方式(既重写一个类加载器的loadClass()方法)。</strong></p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的：为了确保Class文件的字节流中包含的信息符合当前虚拟机的有要求，而且不会危害虚拟机自身的安全。</p><ol><li>文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br>例如: <ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否由不被支持的常量类型(检查常量tag标志)<br>…</li></ul></li><li>元数据验证<br>对自己吗描述的信息进行语义分析，以确保其描述的信息符合Java语言规范的要求<ul><li>这个类是否由父类(除了java.lang.Object之外，所有的类都应当由父类)</li><li>这个类的父类是否继承了不允许被继承的类(被final修饰)<br>…</li></ul></li><li>字节码验证<br>最复杂的一个阶段。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的<ul><li>保证任意时刻操作栈的数据类型与指令代码序列都能配合工作</li><li>保证跳栈指令不会跳转到方法体以外的字节码指令上<br>…</li></ul></li><li>符号引用验证<br>发生在虚拟机将符号引用转化为直接引用的时候，符号引用验证可以看作是对类自身意外(常量池中的各种符号引用)的信息进行匹配校验<ul><li>符号引用中同故宫字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符号方法的字段描述以及简单名称所描述的方法和字段</li></ul></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下：</p><ol><li>这时候进行内存分配的仅包括类变量(static修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为==public static int value = 123==那变量value在准备阶段过后的初始值为0而不是123，因为这时还未开始执行任何Java方法(赋值动作将在初始化阶段才会之心那个)。“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量value会被初始化为ConstatnValue所指定的值。假设上面类变量value的定义为==public static final int value = 123==那么主备阶段value值为123。</li></ol><p>基本数据类型的零值<br>数据类型 | 零值<br>— | —<br>int | 0<br>long | 0L<br>short | (short)0<br>char | ‘\u0000’<br>byte | (byte)0<br>boolean | false<br>float | 0.0f<br>double | 0.0d<br>reference | null</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用：可以是直接指向目标地指针、相对偏移量或是一个能间接定位到目标地句柄。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程地最后一步，才是真正开始执行类中定义的Java程序代码(或者说是字节码)<br>初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p><ul><li><clinit>()方法是由于编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中语句合并产生的，编译器收集的顺序是由语句在源文件中出席那的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问；</clinit></li><li><clinit>()方法与类的构造函数不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。</clinit></clinit></clinit></li><li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></li><li><clinit>()方法对于类和接口并不是必需的，如果一个类中没有静态语句块，也就没有对变量的赋值操作，就不会为这个类生成<clinit>()方法。</clinit></clinit></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>启动类加载器(Bootstrap ClassLoader): 这个类加载器使用C++语言实现，是虚拟机自身的一部分。负责将存放在<java_home> \lib目录中的，或者被-Xbootclasspath擦书所指定的路径中的类库加载到虚拟机内存中。</java_home></li><li>扩展类加载器(Extension ClassLoader): 负责加载<java_home>/lib/ext目录中的，或者被java.ext.dirs系统变量指定的路径中的所有类库。</java_home></li><li>应用程序类加载器(Application ClassLoader): 负责加载用户类路径(ClassPath)上指定的类库</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。一般使用组合(Copmposition)关系来服用父类加载的代码。<br><img src="https://camo.githubusercontent.com/4311721b0968c1b9fd63bdc0acf11d7358a52ff6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f636c6173736c6f616465725f5750532545352539422542452545372538392538372e706e67" alt="shuagnqin"></p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，源代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法，若父加载器为空则默认使用启动类加载作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，在调用自己的findzClass()方法进行加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">           <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>参考：《深入理解java虚拟机 第2版》<br>      JavaGuide：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(一)Java内存区域与内存溢出异常</title>
      <link href="/2019/07/18/JVM1/"/>
      <url>/2019/07/18/JVM1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不在需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出的问题。不过正是因为将内存的控制权力交给了java虚拟机，一旦出现内存的泄露和溢出方面的问题，如果不了解虚拟机是怎么使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><p>JDK 1.8:<br><img src="https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67" alt="jvm内存模型"></p><h3 id="线程私有的"><a href="#线程私有的" class="headerlink" title="线程私有的"></a>线程私有的</h3><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈<h3 id="线程共享的"><a href="#线程共享的" class="headerlink" title="线程共享的"></a>线程共享的</h3></li><li>堆</li><li>方法区</li><li>直接内存(非要运行时数据区的一部分)<h3 id="2-1程序计数器"><a href="#2-1程序计数器" class="headerlink" title="2.1程序计数器"></a>2.1程序计数器</h3>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当线程所执行的字节码的行号指示器。<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></li></ul><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><blockquote><p>程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryErroy情况的区域。</p></blockquote><h3 id="2-2-Java虚拟机栈"><a href="#2-2-Java虚拟机栈" class="headerlink" title="2.2 Java虚拟机栈"></a>2.2 Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><blockquote><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></blockquote><p>Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p><blockquote><p>实际上，Java虚拟机栈是由一个个栈帧组成，每个栈帧中都拥有：局部变量、操作数栈、动态链接、方法出口信息</p></blockquote><p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</p><p>Java虚拟机栈规定了两种异常情况：StackOverFlowError和OutOfMemoryError</p><ul><li>StackOverFlowError：如果下称请求的栈深度大于虚拟机所允许的深度，则抛出此异常。</li><li>OutOfMemoryError：如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，就会抛出磁异常。<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3>本地方法栈与虚拟机栈所发挥的作用非常相似，区别是:</li><li>虚拟机栈为虚拟机执行Java方法(也就是字节码 )服务</li><li>本地方法栈则为虚拟机使用到的Native方法服务。</li></ul><blockquote><p>在Sun  HotSpot虚拟机中把本地方法栈和虚拟机栈合二为一。</p></blockquote><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>与虚拟机栈中一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError两种异常。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p><p>Java堆时垃圾收集器管理的主要区域，因此很多时候被称为<strong>GC堆。</strong>从内存回收的角度看，由于现在收集器基本都采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为：<strong>新生代和老生代</strong>；再细致一点的有：Eden空间、From Survivor空间、To Survivor空间等。<strong>进一步划分的目的是为了更好地回收内存，或者更快的分配内存</strong></p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一逻辑部分，但是它有个别名<strong>Non—Heap(非堆)</strong>，目的应该时与Java堆区分开来。</p><p><strong>在JDK1.8的时候，方法区被彻底移除了，取而代之是元空间，元空间使用的是之际内存。</strong><br>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSIze=N  //设置Metaspace的初始(和最小)大小</span><br><span class="line">-XX:MaxMetaspaceSize=N  //设置Metaspace的最大大小</span><br></pre></td></tr></table></figure></p><h4 id="2-5-1-为什么要将永久代-PerGen-替换元空间-MetaSpace-呢？"><a href="#2-5-1-为什么要将永久代-PerGen-替换元空间-MetaSpace-呢？" class="headerlink" title="2.5.1 为什么要将永久代(PerGen)替换元空间(MetaSpace)呢？"></a>2.5.1 为什么要将永久代(PerGen)替换元空间(MetaSpace)呢？</h4><p>整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存呢的限制，并且永远不会得到Java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为unlimited，这意味着它只受系统内存的限制， -XX:MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则Metaspace将根据运行时的应用程序需求动态地重新调整大小。</p><h3 id="2-6-运行时常量"><a href="#2-6-运行时常量" class="headerlink" title="2.6 运行时常量"></a>2.6 运行时常量</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(用于存放编译器生成的各种字面量和符号引用)</p><p>**JDK 1.7及以后版本的JVM已经将运行是常量池从方法区移了出来，在Java中开辟了一块区域存放运行时常量。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/yunxing.png?raw=true" alt="常量池"></p><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用</strong></p><p>JDK 1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据。</p><p>本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻找空间的限制</p><h2 id="3-HotSpot-虚拟机对象探秘"><a href="#3-HotSpot-虚拟机对象探秘" class="headerlink" title="3. HotSpot 虚拟机对象探秘"></a>3. HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解下HtoSpot虚拟机在Java堆中对象的分配、布局和访问的全过程。</p><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下面便是Java 对象创建过程。<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.jpg?raw=true" alt="对象的创建"></p><h4 id="Step1：类加载检查"><a href="#Step1：类加载检查" class="headerlink" title="Step1：类加载检查"></a>Step1：类加载检查</h4><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须限制性想要赢得类加载过程。</p><h4 id="Stept2：分配内存"><a href="#Stept2：分配内存" class="headerlink" title="Stept2：分配内存"></a>Stept2：分配内存</h4><p>在<strong>类加载检查</strong>通过后，虚拟机将为新生对象<strong>分配内存</strong>。对象所需内存的大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<strong>分配方式</strong>有“<strong>指针碰撞</strong>”和“<strong>空闲列表</strong>”两种，<strong>选择那种分配方式由Java堆是否规整决定，而Java堆是否规整右由所曹勇的垃圾收集器是否带有压缩整理功能决定。</strong></p><h5 id="内存分配的两种方式："><a href="#内存分配的两种方式：" class="headerlink" title="内存分配的两种方式："></a>内存分配的两种方式：</h5><p>选择以上两种分配方式由Java堆是否规整决定，而Java堆内存是否规整，取决于GC收集器的算法是”标记-清除”，还是”标记-整理”(也称作”标记-压缩”),值得注意的是，复制算法内存也规整的<br><img src="https://github.com/SGEEKioi/InterView/blob/master/JVM/img/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png?raw=true" alt="内存分配"></p><h5 id="内存分配并发问题："><a href="#内存分配并发问题：" class="headerlink" title="内存分配并发问题："></a>内存分配并发问题：</h5><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在时机开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式保证线程安全：</p><ul><li>CAS + 失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁二十假设没有冲突而去完成某项操作，如果因为冲突失败就重试，知道成功为止。<strong>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</strong></li><li>TLAB：为每一个线程预先在Eden区分配一块内存，JVN在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h4 id="Step3：初始化零值"><a href="#Step3：初始化零值" class="headerlink" title="Step3：初始化零值"></a>Step3：初始化零值</h4><p>内存分配完成后，虚拟机需要要将分配到的内存空间都初始化为零值(不包括对象头)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4：设置对象头"><a href="#Step4：设置对象头" class="headerlink" title="Step4：设置对象头"></a>Step4：设置对象头</h4><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据、对象的哈希码、对象的GC分代年龄等信息。<strong>这些信息存放在对象头中</strong>。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不用的设置方式。</p><h4 id="Step-执行init方法"><a href="#Step-执行init方法" class="headerlink" title="Step:执行init方法"></a>Step:执行init方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建 才刚刚开始——<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可以用的对象才算完全产生出来。</init></init></p><h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在HotSpot虚拟机中，对下个在内存中存储的布局可以分为3块<strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong></p><p>HotSpot虚拟机中的对象头包括两部分信息：</p><ul><li>用于存储对象自身的的运行时数据(如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等)。</li><li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对其填充部分不是必然存在的，也没有什么特别的意义，仅仅起占位作用</strong>。因为HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的倍数,因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我么的Java程序通过栈上的reference的数据来操作堆上的具体对象.对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ol><li><p>句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br><img src="https://camo.githubusercontent.com/04c82b46121149c8cc9c3b81e18967a5ce06353f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545342542442542462545372539342541382545352538462541352545362539462538342e706e67" alt="jubing"></p></li><li><p>直接指针：如果使用直接针织访问，那么Java堆对象的布局中就必须考虑如果放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址，<br><img src="https://camo.githubusercontent.com/0ae309b058b45ee14004cd001e334355231b2246/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545372539422542342545362538452541352545362538432538372545392539322538382e706e67" alt="zhizhen"></p></li></ol><p><strong>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
